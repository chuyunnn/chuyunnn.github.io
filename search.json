[{"title":"AOP定义和配置","url":"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%BC%80%E5%8F%91/AOP%E5%AE%9A%E4%B9%89%E5%92%8C%E9%85%8D%E7%BD%AE/","content":"概念定义AOP（Aspect Orient Programming）面向切面编程，是一种编程思想，利用AOP可以对业务逻辑的各个部分进行隔离。这种横向切面的方式可以注入**和主业务无关的功能，比如事务管理和日志管理**\n​\t&#x3D;&#x3D;&gt; 可以让开发者在不修改源码的同时，为业务组件添加通用功能（让AOP去修改源码）\n本质：对方法前后进行拦截，在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚\n是面向对象编程（Object-oriented Programming，OOP）的补充。OOP的核心单元是类，AOP的核心单元是切面。\n\nspring支持的两种事务：\n\n编程式事务：把事务管理代码嵌入业务代码中，一般用TransactionTemplete比较多\n声明式事务：用AOP管理事务\n\n\n实现方式两种实现方式：\n\nAspectJ 静态 AOP 实现， AOP 框架在**编译阶段**对程序源代码进行修改，生成了静态的 AOP代理类(生成的 *.class 文件已经被改掉了，需要使用特定的编译器)\n动态 AOP 实现， AOP 框架在**运行阶段**对动态生成代理对象（在内存中动态生成 AOP 代理类），如 SpringAOP\n\nAOP动态代理的两种方式：\n\nJDK动态代理：（默认使用，如果满足条件）使用JDK动态代理，只能对实现了接口的类生成代理对象\nCGLIB代理：适用于没有接口的类（基于继承），依赖于Spring内置的CGLIB，不能对final类or方法生成代理\n\n五大概念：\nJoinPoint（连接点）：哪里可以设置“安检”，就是程序运行中的每一个方法\nPointcut（切点）：哪里真的设置了“安检”。也就是通知功能被应用的范围，比如日志切面的应用范围是所有controller的接口（只给controller层的代码加日志），一般用@Pointcut来定义切点表达式\nAdvice（通知）：“安检”具体做什么（什么时候做、内容是什么）。也就是切面必须要完成的各个具体工作，比如日志切面需要记录接口调用前后的时长，就需要在调用接口前后记录时间，再计算差值。\n\n​\t五种通知方式：\n​\t\t@Before：在方法调用之前\n​\t\t@After：在方法调用之后\n​\t\t@AfterReturning：目标方法返回后\n​\t\t@AfterThrowing：目标方法抛出异常后\n​\t\t@Around：整个目标方法包裹起来，在被调用前和调用之后分别执行通知方法\n\nAspect（切面）：安检系统。切点+通知，通常使用@Aspect来定义\nProxy（代理对象）：安检门，需要通过这个逻辑。AOP的底层实现，就是JDK动态代理orCGLIB代理\n\nSpring 容器扫描切面（@Aspect）&#x3D;&#x3D;&gt; 创建代理对象（JDK&#x2F;CGLIB）&#x3D;&#x3D;&gt; 客户端调用方法 → 代理先执行 Advice → 调用目标方法 → 执行后置 Advice &#x3D;&#x3D;&gt; 返回结果给客户端\n实操：使用AOP记录接口访问日志实例放在xx-core模块下的mdc包下\n定义了五个类：MdcAspect、MdcDot、MdcUtil、SelfTraceldGenerator、SkyWalkingTraceldGenerator\n1. SkyWalkingTraceldGenerator类从SkyWalking中拷贝，是一种生成traceId的方式\n这里SkyWalking：开源的应用性能监控系统，支持对**分布式系统**中的服务进行追踪、监控、诊断\n​\t官网：https://skywalking.apache.org/\n主要方法为静态的generate方法，用来生产traceid，它包含三个部分：\n\n应用实例ID（UUID）：区分不同服务器节点。即使两台机器在同一毫秒生成ID，机器ID也可以把他们区分开\n当前线程的ID：区分同一台机器上并发执行的不同请求\n由时间戳（毫秒级）和线程序列号（0-9999之间的数）组成的数字：确保同一个线程在极短时间内连续生成 ID 也不重复\n\n使用这个工具类可以生产一个既唯一由包含上下文信息的traceid，可以更好的追踪和理解**分布式系统**中的请求执行路径\n\n💡 引入traceid &#x3D;&#x3D; 为分布式场景做准备or已经运行在**分布式场景**中\n​\t在传统的单机项目中，如果要查日志，只需要根据日志文件按时间顺序查找就行了。但到了分布式环境，情况变得复杂：\n\n请求跨进程：一个请求可能从vue前端到网关，再到用户服务，再到数据库\n日志分散：这些服务的日志分散在不同的服务器或容器上。\n并发干扰：成千上万个请求同时发生，日志交织在一起\n\n​\tTraceID就像给每个请求贴上了一个唯一的“身份证号”。无论这个请求跨越多少台服务器，只要拿着这个 ID 去日志系统（如 ELK 或 SkyWalking）里一搜，就能把分散在各处的日志串成一条完整的线\n​\t微服务架构 &#x3D;&#x3D;&gt; traceid是必选的，要不当生产环境报错的时候，无法确定A服务的报错是由B服务的哪个请求引起的\n💡 但是你的单机项目如果开启了异步线程（比如AOP记录日志）普通单日志就断了，traceid可以让你知道**这个异步任务是哪个请求触发的**\n\nTraceID 通常是这样被“整合”进去的：\n\n切面拦截：利用 Spring AOP，在每个 Controller 请求进来时，调用 SkyWalkingTraceIdGenerator.generate() 生成一个 ID。\n上下文传递：将这个 ID 存入 **MDC（日志诊断上下文）**。这样你在日志配置（logback.xml）里只需要写一个 %X&#123;traceId&#125;，所有的 log.info 就会自动带上 ID。\nKnife4j 展示：在 Knife4j 测试接口时，返回结果里带上这个 TraceID。前端如果报错，直接把 ID 截图给你，你反手在日志里一搜，秒定代码位置。\n\n\n2. SelfTraceldGenerator类自定义traceid生成器\npublic static String generate() &#123;        StringBuilder traceId = new StringBuilder();        try &#123;            // 1. IP - 8：取得当前机器的IP地址，转换为16进制形式            traceId.append(convertIp(IpUtil.getLocalIp4Address())).append(&quot;.&quot;);            // 2. 时间戳 - 13：使用java 8 的instant类获取当前的毫秒级时间戳            traceId.append(Instant.now().toEpochMilli()).append(&quot;.&quot;);            // 3. 当前进程号 - 5：使用java的ManagementFactory类获取当前JVM进程的PID，总长度为5位            traceId.append(getProcessId());            // 4. 自增序列 - 4：在1000-9999之间循环自增的数            traceId.append(getAutoIncreaseNumber());        &#125; catch (Exception e) &#123;            log.error(&quot;generate trace id error!&quot;, e);            return UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);        &#125;        return traceId.toString();    &#125;\n\n3. MdcUtil工具箱，封装了MDC操作（增删改查traceid）\n4. MdcDot一个自定义java注解，用来标记哪些方法或类需要被“切入”日志逻辑 &#x3D;&#x3D;&gt; 用于定义切点\n@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface MdcDot &#123;    String bizCode() default &quot;&quot;;&#125;\n\n5. MdcAspect真正的核心，它负责拦截请求、解析业务编码、记录耗时 &#x3D;&#x3D;&gt; 真正的切面\n\n切点\n\n@Pointcut(&quot;@annotation(MdcDot) || @within(MdcDot)&quot;)\n\n这行代码定义了范围：只要方法上挂了 @MdcDot 注解，或者整个类上挂了 @MdcDot（@within），就是目标\n\n连接点\n\n@Around(&quot;getLogAnnotation()&quot;)public Object handle(ProceedingJoinPoint joinPoint) throws Throwable &#123;    // ...&#125;\n\n这里的joinPoint就是连接点，它代表了当前正在被调用的那个方法（比如Controller接口）。通过它可以拿到方法名、参数等\n\n通知\n\n示例中使用的是@Around（环绕通知），它是最强的通知，因为它包裹了整个方法：\n\n方法执行前：调用 addMdcCode 往日志上下文里塞入 bizCode（业务编码）。\n\n方法执行中：joinPoint.proceed() 让原有的业务逻辑运行。\n\n方法执行后：在 finally 块里计算耗时并打印日志，最后重置 MDC。\n\n\n\nProxy代理对象\n启动 Spring 项目并在 Service 上加了 @MdcDot 时，Spring 会在内存中为这个类生成一个代理对象。你调用的其实是代理对象，它先跑 MdcAspect 的逻辑，再去调你的原代码。\n\n\n总结这个方案的核心技术点有两个：\nA. MDC (Mapped Diagnostic Context)：日志框架（Logback&#x2F;Log4j）提供的一个线程绑定的映射表。\n​\t在springboot这种多线程环境下，每个HTTP请求都会被分配给一个独立的**线程处理。MDC内部封装了ThreadLocal**&lt;Map&lt;String, String&gt;&gt;。而ThreadLocal存的数据是绑定在当前线程上的 &#x3D;&#x3D;&gt; 每个线程有自己的MDC）\n​\t日志框架比如Logback在打印每一行日志之前都会写一段这样的逻辑：\n​\t\t“让我看看当前运行我的线程是谁？噢，是线程 A。线程 A 的 MDC 笔记本里存了什么？存了 traceId&#x3D;ABC。好，我打印的时候把它加上。”\n\n作用：让不同线程（不同请求）的日志带上属于自己的标识（TraceId 或 业务代码）。\n&#x3D;&#x3D;&gt; 可以通过 grep “TraceId” 把请求完整的生命周期找出来\n\n\n\nB. Spel 表达式解析 (loadBizCode 方法)\n使用了 Spring Expression Language (Spel)\n\n效果：你在注解里写 @MdcDot(bizCode = &quot;#user.id&quot;)，切面会动态地从方法的参数里找到叫 user 的对象，并取出它的 id。这让你能动态地把业务数据（如用户ID、订单号）塞进日志里。\n\n配置好之后，在业务代码里面只需要打标签就行了：\n@RestControllerpublic class UserController &#123;    // 只要加了这个注解，这个接口的日志就会带上 bizCode，并记录耗时    @MdcDot(bizCode = &quot;#userId&quot;)     @GetMapping(&quot;/info&quot;)    public String getInfo(String userId) &#123;        log.info(&quot;正在查询用户信息...&quot;); // 这行日志会自动带上 bizCode        return &quot;ok&quot;;    &#125;&#125;\n\n除此之外还需要配置日志格式： 在 logback.xml 中，你需要在 pattern 里加上 %X&#123;bizCode&#125; 和 %X&#123;traceId&#125;，否则这些信息只在内存里，不会打印到控制台或文件。\nAOP实现方式： Spring AOP（基于代理的 AOP），具体来说是：\n\n声明式 AOP：通过注解和配置来实现，不需要手动修改业务逻辑\n运行时织入：在 Spring 容器启动并初始化 Bean 的时候，动态创建代理对象\n\n","categories":["基础知识","开发"],"tags":["AOP"]},{"title":"API配置","url":"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%BC%80%E5%8F%91/API%E9%85%8D%E7%BD%AE/","content":"解决让前端知道怎么调，如何快速测试的问题\nRESTful web测试测试接口能不能跑通\nRESTful是一种流行的接口设计风格（GET、POST、PUT、DELETE）\n测试方法：Knife4j的页面自带“发送请求”按钮，不需要postman或者网页，直接在生成的文档页面输入参数，点击发送就可以查看后台返回结果\nSwagger官网：https://swagger.io/\n核心协议&#x2F;规范，是API界的说明书标准\n作用：自动扫描代码，比如springboot里的controller。根据代码中的注解生成一个包含所有**接口地址、参数要求、返回值格式**的文件 &#x3D;&#x3D;&gt; 将项目中想要暴露的接口展示在页面上，然后就可以直接调用和测试\n​\t@Api 或 @ ApiOperation\n格式：JSON 或 YAML格式\n问题：\n\n原生界面Swagger-UI比较老\n\n布局不直观（接口多的时候）\n\n没有搜索功能\n\n请求参数为JSON的时候没办法格式化\n\n返回结构无法折叠\n\n\nKnife4j官网：https://doc.xiaominfo.com/\n码云地址：https://gitee.com/xiaoym/knife4j\n示例地址：https://gitee.com/xiaoym/swagger-bootstrap-ui-demo\n针对java生态的Swagger的增强版\n\n使用Swagger的逻辑来解析接口，重新做了一套UI界面\n\n优点：\n\n在API文档中使用Markdown语法，可以使文档更具可读性和易于维护\n\n将API文档导出为离线的HTML、PDF或Markdown文件，方便分享\n\n支持在不同的环境（比如开发、测试、生产）中使用不同的 API 文档配置\n\n支持动态参数，允许用户在运行时修改 API请求的参数，提高测试的灵活性\n\n界面清晰：树形菜单+接口详情\n\n支持接口全局搜索、参数缓存、方便的Debug调试界面\n\n\n项目整合因为Knife4j遵循Swagger 的使用方式，所以可以无缝切换\n\n添加依赖 pom.xml\n\n&lt;dependency&gt;  &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;  &lt;artifactId&gt;knife4j-openapi2-spring-boot-starter&lt;/artifactId&gt;  &lt;version&gt;$&#123;knife4j.version&#125;&lt;/version&gt;&lt;/dependency&gt;\n\n\n创建java配置类，比如Knife4jConfig.java，使用@EnableKnife4j注解启用Knife4j\n\n/** * Swagger/OpenAPI 配置类 * 作用：自动生成接口文档，支持在线调试接口 */@Configuration  // 标记该类为Spring配置类，Spring启动时会自动加载并解析其中的@Bean方法@EnableOpenApi   // 启用OpenAPI 3.0支持，是Swagger 3.x的新注解，替代了Swagger 2.x的@EnableSwagger2public class SwaggerConfig &#123;    /**     * 创建Docket实例，作为Swagger的核心配置对象     * Docket是Swagger的主构建器，用来配置文档生成的各项参数     */    @Bean  // 将该方法返回的Docket对象注册为Spring Bean    public Docket docket() &#123;        Docket docket = new Docket(DocumentationType.OAS_30)  // 指定使用OpenAPI 3.0规范                .apiInfo(apiInfo())  // 用来定义API文档的元数据，包括标题、描述、版本、联系人信息等，这些信息会在 Swagger UI 中展示                .enable(true)  // 是否启用Swagger，生产环境建议设为false                .select()  // 开启接口选择器：初始化并返回一个API选择构建器，用于配置接口扫描范围                // 指定要扫描的controller包路径，Swagger只会生成该包下Controller的接口文档                .apis(RequestHandlerSelectors.basePackage(&quot;www.xx.controller&quot;))                // 配置要生成文档的路径规则，PathSelectors.any()表示所有路径都生成                .paths(PathSelectors.any())                .build();  // 构建Docket实例        return docket;    &#125;    /**     * 构建API文档的基本信息     * 这些信息会显示在Swagger UI的顶部     */    private ApiInfo apiInfo() &#123;        return new ApiInfoBuilder()                .title(&quot;xx&quot;)  // 文档标题                .description(&quot;xx&quot;)  // 项目描述                .contact(new Contact(                        &quot;xxx&quot;,  // 联系人姓名                        &quot;https://xx.com&quot;,  // 联系人官网                        &quot;www.xxx@xx.com&quot;  // 联系人邮箱（图片中显示不完整，此处为示例）                ))                .version(&quot;v1.0&quot;)  // 接口版本号                .build();  // 构建ApiInfo实例    &#125;&#125;\n\n或者在application.yml文件中设置属性（结果相同）\nknife4j:  enable: true # 设置为true来启用Knife4j  # 包含api文档的基本元数据信息  openapi:    title: xx # 文档标题    description: xx # 项目描述，说明技术栈    version: 1.0.0 # 接口版本号    concat: # 项目相关的联系信息（数组形式，可多行）      - xx      - https://xx.com      - https://github.com/xx    license: Apache License 2.0 # 项目许可证    license-url: https://github.com/xx # 许可证地址    email: xx@xx.com # 联系邮箱  # 定义接口分组：admin和front  group:    # 后台管理接口分组    admin:      group-name: 后台接口分组 # 分组名称，在文档页面中显示      api-rule: package # 分组规则：按包路径扫描（package）      api-rule-resources: # 指定包名，Knife4j将扫描此包下所有api接口，添加到此分组        - com.github.xx.forum.web.admin    # 前台用户接口分组    front:      group-name: 前台接口分组      api-rule: package      api-rule-resources:        - com.github.xx.forum.web.front  ## 增加访问权限 ==&gt; 添加basic认证功能（需要登录）  basic:   \tenable: true   \tusername: admin   \tpassword: 123456\n\n\n在测试类中添加Knife4j的接口\n\n/*\t@ApiOperation 描述一个具体的API操作\t主要属性：\t\t- value: api操作的简短描述，会显示在api文档中\t\t- notes: api操作的详细描述，会显示在api文档中\t\t- tags: api操作的标签，用来对api进行分类和分组*/@ApiOperation(&quot;测试 Knife4j&quot;)@RequestMapping(value = &quot;/testKnife4j&quot;, method = RequestMethod.POST)public String testKnife4j() &#123;  return &quot;xx&quot;&#125;\n\n\n运行项目，输入http://localhost:8080/doc.html 就可以看到API文档了\n\n","categories":["基础知识","开发"],"tags":["API","开发"]},{"title":"Hello World","url":"/uncategorized/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Diffusion over 隐式神经表示INR","url":"/papers/work2/Diffusion-over-%E9%9A%90%E5%BC%8F%E7%A5%9E%E7%BB%8F%E8%A1%A8%E7%A4%BAINR/","content":"问题表述使用 **神经网络表示函数 φ(x)**。\n\n**φ(x)**：学习一个函数本身。该函数需要满足某些物理 &#x2F; 几何 &#x2F; 数学约束（方程）。\n\n约束：φ 及其导数必须满足某个条件\nC &#x3D; 0\n这对应于一种 隐式问题表述。\n\n\n例如，给定一阶导数约束：\n∇φ(x) = f(x)\n\n可以等价地写成如下隐式形式：\nC(x, φ, ∇φ, ∇²φ) = ∇²φ(x) − f(x) = 0\n\n其中x 表示空间坐标，φ(x) 表示 RSS，C 表示规则检查器。当 C &#x3D; 0 时，函数 φ 被认为是合法的。\n这里 φ 不是通过显式公式计算得到的，而是由一组“规则”所定义和约束的。\n因此，INR 不是一个回归问题，而是一个：寻找合法函数的问题\n\n（合法函数 &#x3D; 满足所有约束条件的解）\n\n在一组约束中：\nC_m(a(x), φ(x), ∇φ(x), ∇²φ(x), …)\n\n寻找一个函数 φ满足m 条规则。不同规则的形式可能不同：\n\n有的只依赖 ∇φ(x)\n有的只依赖 ∇²φ(x)\n有的还需要外部已知量 a(x)\n\n其中已知条件（PDE）通常由 PDE 给出，例如：\n\n源项（source term）\n边界条件（boundary conditions）\n\n我们使用 Ω_m 表示第 m 条规则的生效区域，第 m 条约束并不要求在整个空间内都成立。\n损失函数整体损失函数定义为：\nL = ∫_Ω  Σ_&#123;m=1&#125;^M  |Ω_m(x)| · |C_m(x)|  dx\n\n其中Ω 表示整个空间，x 表示空间中的每一个点。\n对所有 x 进行积分。Σ_{m&#x3D;1}^M 表示将所有约束的违反程度进行累加。\n\n当 x ∈ Ω_m 时，第 m 条约束生效\n\n当 x ∉ Ω_m 时，该约束在该位置失效\n\n\n这种设计显式地考虑了不同空间位置上，不同约束是否成立的问题。\n数据集","categories":["papers","work2"],"tags":["diffusion","INR"]},{"title":"重新发布问题","url":"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%BC%80%E5%8F%91/%E2%80%9C%E9%87%8D%E6%96%B0%E5%8F%91%E5%B8%83%E2%80%9D%E9%97%AE%E9%A2%98/","content":"使用全局字典为什么要用全局字典？\n假设你的文章表里面有个status字段用来表示文章状态，&#x3D;1表示已发布，&#x3D;2表示草稿，&#x3D;3表示已删除\n没有全局字典的话，你要在代码里写死映射关系：\n// 硬编码：1=已发布if (article.getStatus() == 1) &#123;    return &quot;已发布&quot;;&#125; else if (article.getStatus() == 2) &#123;    return &quot;草稿&quot;;&#125;\n\n如果新增一个状态4&#x3D;审核中，你就要修改代码，重新发布才能生效，很麻烦\n但是如果有全局字典的话，代码可以从字典表中动态查询映射关系，不需要硬编码\n// 动态从字典表查询状态描述public String getStatusDesc(Integer status) &#123;    return dictCommonMapper.getDescByTypeAndCode(&quot;article_status&quot;, status.toString());&#125;\n\n因此优点：\n\n减少硬编码：把业务代码（状态、类型、性别等）从代码中剥离，让代码更易于维护\n配置灵活：新增业务的时候只需要操作数据库，不需要修改代码和重启服务 &#x3D;&#x3D;&gt; 在频繁变动的业务场景很有用\n统一管理：业务代码都在一个表中，方便配置\n多端一致：前后端、app都在表中取描述，避免了各端硬编码导致的展示不一致\n\n库表设计dict_commonid - 主键type_code - 字典类型dict_code - 字典类型的值编码dict_desc - 字典类型的值描述sort_no - 排序编号remark - 备注create_time - 创建时间update_time - 更新时间\n","categories":["基础知识","开发"],"tags":["开发","面向实际"]},{"title":"个人博客搭建","url":"/%E4%BB%93%E5%BA%93/%E9%A1%B9%E7%9B%AE/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","content":"使用hexo（node.js工具）+GitHub pages静态网页，支持markdown\n网页链接：https://chuyunnn.github.io/\n常用指令新建文件：（文件分类需求）\nhexo new post &quot;xx/xx&quot; ## eg:&quot;papers/我的新论文&quot;\n\n发布文章：\nhexo clean ## 清理缓存hexo g  ## generate生成静态网页hexo d ## deploy部署到github中（推送到github仓库）\n\n有延迟，有的新建文章、更新内容不会一次同步上去\n本地预览：\nhexo cleanhexo s\n\n刷新 localhost:4000，确认排版、图片都没有问题。\n域名想要个人域名可以：\n\n买域名：去阿里、腾讯或 Namecheap 买一个\n设置 DNS：在域名后台设置一条 CNAME 记录，指向 你的用户名.github.io\nGitHub 设置：在仓库的 Settings -&gt; Pages 里，填写你的 Custom Domain\n\n图片处理","categories":["仓库","项目"],"tags":["博客","项目","搭建"]},{"title":"实体类命名 VO、DTO、DO、PO","url":"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%BC%80%E5%8F%91/%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%91%BD%E5%90%8D-VO%E3%80%81DTO%E3%80%81DO%E3%80%81PO/","content":"总体概念\nVO（view object）：\n视图对象，用于展示层，将某个指定页面or组件的所有数据封装起来。\n封装返回给前端的数据实体 \n​\t&#x3D;&#x3D;&gt; 展示层需要显示的数据，也就是**后端和前端进行交互**的对象，返回vo\n\nDTO（data transfer object）：\n数据传输对象，用于展示层与服务层之间的数据传输对象\n返回给前端的数据实体 \n​\t&#x3D;&#x3D;&gt; 服务层需要接受的数据和返回的数据，***后端服务和服务之间的交互***对象，返回dto\n\nDO（domain object）：\n领域对象，从现实世界抽象出来的有形or无形的业务实体\n**数据库实体**，或者叫po&#x2F;entity，do适用于小型项目，大型项目需要po&#x2F;entity\n\nPO（persistent object）：\n持久化对象，跟持久层（一般是关系型数据库）的数据结构形成一一对应关系【比如数据库的一个（多个）字段对应PO的一个（多个）属性】\n\nreq：\n前端传递给后端的请求参数\n\n\n关系分析为什么不在service层直接返回DO\n为了解耦和灵活性：\n\n​\tDO和数据库深度绑定，如果在service层直接返回DO会导致前端和数据库绑定 &#x3D;&#x3D;&gt; 如果修改了数据库字段名，如果不手动在controller转换，前端json字段会改变，导致前端页面崩溃\n​\t数据库字段是原子化的，但前端页面可能需要展示“格式化后的金额”、“加密后的手机号”或“合并后的地址”。DO 很难直接满足这些展示逻辑\n\n防止数据泄露：\n\n​\tDO 通常包含表中的所有字段，包括一些敏感字段。如果直接返回 DO，这些字段会被序列化成 JSON 发给前端。即使前端页面不显示，黑客通过 F12 调试工具也能直接看到你数据库里的底牌\n\n避免脏检查和懒加载坑：\n\n​\t如果使用的是 Hibernate 或 JPA 等 ORM 框架：\n​\t\t懒加载异常：DO 可能包含与其他表的关联关系（如 User 对象包含 Order 列表）。如果你在 Controller 层才去访问这些未初始化的关联字段，会报 LazyInitializationException\n​\t\t无意识的更新：在某些框架中，DO 处于“持久化状态”。如果你在 Controller 或 View 层不小心改了 DO 的某个属性，框架可能会在事务结束时自动将修改同步回数据库，产生不可预知的脏数据\n因此正确的流程：\nservice层：调用mapper&#x2F;DAO拿到**DO**\n\nservice或controller层：将DO转换为**DTO或VO**\n\n返回：只给前端返回需要的、脱敏后的数据\n\n\nDO和PO简单来说：PO 是“数据库的映射”，而 DO 是“业务逻辑的载体”。\n1. PO (Persistent Object) ：持久化对象，是和数据库表结构一一对应的对象来源：**通常由 ORM 框架（如 Hibernate, MyBatis）生成或使用**\n生命周期：它的生命周期与数据库事务息息相关。在 Hibernate 中，PO 有“瞬时、持久、托管”三种状态\n特征：\n\n字段名通常与数据库列名一致（或通过注解映射）\n不包含任何业务逻辑，只包含简单的 Getter&#x2F;Setter\n主要存在于 DAO&#x2F;Repository 层（持久层）\n\n2. DO (Data Object &#x2F; Domain Object)：数据&#x2F;领域对象。DO 的定义在不同的规范（如阿里巴巴 Java 开发手册）中可能有所不同，但通常指领域模型对象来源：**根据业务需求设计**，不一定完全对应单张数据库表\n特征：\n\n它代表了业务实体（如“订单”、“用户”）\n可以包含业务逻辑（例如：计算订单总价的方法）\n主要存在于 Service 层（业务逻辑层）\n\n注意：在很多国内互联网公司的规范中，DO 被等同于 PO，统指从数据库查出来的那个原始对象\n","categories":["基础知识","开发"],"tags":["实体类","实体类命名"]},{"title":"工具安装","url":"/%E4%BB%93%E5%BA%93/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/","content":"在macOS arm64 Apple M2芯片下\n开发工具SQL直接使用homebrew，跳过复杂的权限认证\nbrew install mysql ## 安装brew services start mysql ## 启动\n\nredisbrew install redis ## 安装redis-server ## 临时启动sudo service redis-server start ## 服务方式查询redis-cli ## 连接redis\n\nmaven下载地址：https://maven.apache.org/download.cgi\n环境配置：\nvim ~/.bashrc## 在文件最后添加maven的解压目录export MAVEN_HOME=xxexport PATH=$&#123;MAVEN_HOME&#125;/bin:$&#123;PATH&#125;## 保存并退出，让配置变更生效source ~/.bashrc## 验证mvn --version\n\n本机输出：\nApache Maven 3.9.9 (8e8579a9e76f7d015ee5ec7bfcdc97d260186937)Maven home: /opt/homebrew/Cellar/maven/3.9.9/libexecJava version: 23.0.2, vendor: Homebrew, runtime: /opt/homebrew/Cellar/openjdk/23.0.2/libexec/openjdk.jdk/Contents/HomeDefault locale: zh_CN_#Hans, platform encoding: UTF-8OS name: &quot;mac os x&quot;, version: &quot;14.5&quot;, arch: &quot;aarch64&quot;, family: &quot;mac&quot;\n\n辅助工具warp官网：https://www.warp.dev/\n开源：https://github.com/warpdotdev/Warp\n暂时没有接着看教程，因为说我不能用ai生成相关工具对话，使用工作流这些。作为终端挺好用的，支持tab填充还有#查询指令\n🌟 其他搜索一下解决办法\n","categories":["仓库"],"tags":["整理","安装"]},{"title":"diffusion文章总结","url":"/papers/conclusion/%E6%96%87%E7%AB%A0%E6%80%BB%E7%BB%93/","content":"radiodiff不基于测量值，仅输入环境信息、发射机位置信息\n利用radiomapseer中的车辆数据集模拟动态变化\n使用条件生成的解耦扩散模型（DDM），VAE对图像进行编码，unet解码噪声\n\n3D radiodiff关注不同高度和环境影响，分别实验了有采样和无采样的情况\n高度条件的RM生成，使用DDPM\n\nWIFI-Diffusion极低采样场景问题：1%到10%\n根据环境信息、传播规律信息、收集的无线电样本生成RM\nboost block：输入 障碍物布局、无线电传播规律、收集得到的无线电样本 到self-attention UNet  &#x3D;&#x3D;&gt; 优化diffusion生成效果（采样点、预测值、临界点）\ngeneration block：DDPM加噪声，DDIM去噪（输出一组生成图像）\nelection block：使用数学无线电传播模型作为指导选择radio map\n\n\nDDPM切换为DDIM无需再训练\n\n\nResNet[16]在过去几年中被广泛应用于特征提取应用。 在WiFi-Diffusion中，我们使用它来预测res。我们通过向ResNet提供xa、xzi、处理信息（边缘检测）的拉普拉斯高斯算子（LoG）和xzi的高功率图（图8所示的示例）来学习校正因子res。\n其他方法MFFGCN关注空白区域（观测值分布不均匀）\n实现稀疏观测（10-300）和环境地图的多模态特征融合\n双编码器unet，补丁级图卷积优化网络\n粗估计 &#x3D;&#x3D;&gt;  优化\n从环境信息中获取更多的信号传播特征，要么必须基于无约束区域的经验来指导观测约束区域的重建。\n\n\n\n\nTiRE-GAN: Task-Incentivized Generative Learning for Radiomap Estimation利用无线电传播模型的物理原理和来自稀疏观测的数据统计 &#x3D;&#x3D;&gt; 任务激励生成学习模型TiREGAN\n\n引入无线电深度图来捕捉无线电传播和阴影效应的总体模式\n使用任务激励网络的物理条件cGAN，根据下游任务为无线电深度图补偿提供反馈\n\n\n图1所示。 TiRE-GAN总体结构由4部分组成：\n1)基于模型的数据预处理模块利用输入的观测信息（即建筑物图和发射机位置）生成无线电深度图，然后将四层叠加在一起作为输入； \n2)无线电地图生成模块采用cGAN发生器结构，学习并生成无线电地图预测； \n3)反馈模块由两个部分组成：cGAN鉴别器和任务激励网络。 两个模块都产生一个损失项作为反馈，以改进生成器； \n4)为培训指导提供额外损失期的下游任务。\nRadioGAT: A Joint Model-Based and Data-Driven Framework for Multi-Band Radiomap Reconstruction via Graph Attention NetworksOpenStreetMap\n关注 空间、时间、频带稀疏样本，多频段RM重建\n图形注意力网络（GAT）\n不依赖 模拟数据 或 完整的结构化地面事实 &#x3D;&#x3D;&gt; 使用masked GAT，不基于完整的地面数据\n利用无线电传播模型来捕获相关性 &#x3D;&#x3D;&gt; radio depth map\n：1)基于模型的空间-谱相关编码； 2)数据驱动的跨带泛化\n基于频率的射频深度图 &#x3D;&#x3D;&gt; 不同频率有不同的深度图，用于构造邻接矩阵\n\n设计编码策略，将稀疏的多波段数据转换为图形结构，该编码策略利用无线电传播模型来捕获数据中固有的空间-频谱相关性。\n集中在不同区域的空间相关性上。 MB-RMR方法不仅可以利用带内空间相关性，还可以利用相同空间坐标下的带间相关性。\n\n带内空间相关性：同一“频带”或者“通道”里的数据，不同空间位置之间可能存在规律性\n带间相关性：不同“频带”或者“通道”在同一空间位置上也可能相关\n带 &#x3D;&#x3D;&gt; 频带\n\n使用一个频带去预测别的频带的图像\n\n请注意，基于图的无线地图估计可以被表述为半监督学习[38]，其中RSS可以被视为每个节点的注释（标签 label），而环境和几何信息可以被视为特征。 \n标注节点和未标注节点都要参与图的学习，图的边是根据特征构造的。 以E(k) b的构建为重点，介绍了现有的基于邻接性、环境信息和发射机信息的三种编码方法，并在此基础上提出了基于模型的相关编码方法。\n\n基于图的无线地图估计\n\n\n你可以把“无线地图”理解为一个二维&#x2F;三维空间里信号强度的分布图。\n“基于图”意味着我们把空间中的接收点或者位置抽象成图里的节点，节点之间有边。\n\n\n半监督学习\n\n\n有些节点有测量值（RSS，Received Signal Strength，信号强度）——这就是“标注节点”。\n有些节点没有测量值，只能用周围信息去推断——这就是“未标注节点”。\n半监督学习就是同时利用“有标注”和“无标注”数据进行学习。\n\n\nRSS是节点的注释，环境和几何信息是特征\n\n\n节点的“标签”（annotation）就是信号强度RSS。\n节点的“特征”是与环境和位置相关的信息，比如建筑物位置、障碍物、发射机位置等等。\n\n无标注的节点参与学习的方法：\n\n标签传播（Label Propagation）：假设节点A有RSS标签，节点B没有。\n\n节点B通过图上的边“看邻居”，用邻居节点的标签信息来更新自己的估计值。\n\n半监督图神经网络（GNN）\n\nGNN会把每个节点的特征（位置、环境信息、发射机信息）和邻居节点的信息混合，生成节点表示。训练时只用标注节点的损失（例如RSS预测误差）来反向传播，但因为网络是全图的，无标注节点的表示也会被更新。\n换句话说，无标注节点参与“信息传递”，帮助模型学习更平滑、符合图结构的表示。\n&#x3D;&#x3D;&gt; 无标注节点不参与反向传播，最后（测试）是预测无标签节点的值。其余时刻均只关注有标签节点的loss\nGAT VS GNN：\n\n传统GNN（比如GCN）在更新节点表示时，会把邻居节点的特征平均或加权平均后传递给自己。\nGAT的创新点：不是简单平均，而是用注意力机制给不同邻居分配不同权重。\n\n换句话说，它会自己学：“哪个邻居的信息对我最重要，我就给它更高的权重。”\n\n","categories":["papers","conclusion"],"tags":["notes","conclusion"]},{"title":"数据集","url":"/radio-map-dataset/%E6%95%B0%E6%8D%AE%E9%9B%86/","content":"实测数据集1. 暂未发布的实测数据集地址：https://www.radiomaps.org/rm/resources\ngithub仓库：https://github.com/fachu000/deep-autoencoders-cartography/tree/master\n文章：https://arxiv.org/abs/2310.11036\n2. 实测数据集  RSRPSetCell-Level RSRP Estimation With the Image-to-Image Wireless Propagation Model Based on Measured Data\ngithub仓库（代码）：https://github.com/ZhengSaber/Cell-Level-RSRP-Estimation\n数据集地址：https://ieee-dataport.org/documents/rsrpseturban-radio-map-dense-urban\n\n[real-world dataset] Yi Zheng, March 9, 2022, “RSRPSet_urban: Radio map in dense urban “, IEEE Dataport, doi:\n\n使用（论文）：\n\nPhysics-Informed Neural Networks for Path Loss Estimation by Solving Electromagnetic Integral Equations\nhttps://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=11114848\nhttps://ieeexplore.ieee.org/document/11143592\n\nGAN_train.py # Running this code to training the Pix2Pix model on RSRPSet_urban for real-world RSRP estimation.GAN_inference.py # inferencing the Pix2Pix model in RSRPSet_urban.UNet_train.py # training the UNet model on RSRPSet_urban.UNet_inference.py # inferencing the UNet model on RSRPSet_urban.## simulation dataset ==&gt; radiomapseersim_RadioGAN_train.py # training the Pix2Pix model on simulation dataset.sim_RadioGAN_inference.py # inferencing the Pix2Pix model on simulation dataset.Note: before training the model, you may need to revise the dataset path and model save path in train code.\n\n\n\n模拟数据集1. 3D地图数据集UAV-Aided Radio Map Construction Exploiting Environment Semantics\n数据集链接：https://github.com/6wj/radiomap-uav/tree/main\n使用：运行matlab文件\n2. 多地形场景、多高度、多频段、多气候数据集Generative AI on SpectrumNet: An Open Benchmark of Multiband 3D Radio Maps\n数据集说明：\n\n3 个空间维度、5 个频段、11 个地形情景和 3 个气候情景的无线电地图\n使用生成式AI的方法\n包含了11种不同地理特征的地形场景：密集城市、普通城市、乡村、郊区、山区、森林、沙漠、草原、岛屿、海洋、湖泊 \n每个区域提供三个不同高度的无线电地图：距地面1.5m、30m和200m，分别反映地面节点、建筑高度节点和空中节点的无线电地图。 为了说明全频段无线电传播，包括从150 MHz到22GHz的五个不同频率的无线电图，覆盖了无线网络的大部分工作频率。 此外，场景的变化对应于不同的气候、建筑材料和地形材料，这也会影响现实世界中的无线电传播。 因此，这些参数也被注释以用于生成每个无线电地图。\n\n文件命名格式：\n\nnpz：npz格式的文件包含特定区域的地形与建筑信息。npz文件的命名规则为“T[xx]C[x]D[xxxx] n[xx] bdtr”\n\njpg：jpg格式文件为单一频率下某区域的无线电图与地形信息的可视化图像。jpg文件命名规则为“T[xx]C[x]D[xxxx] n[xx] f[xx] visual”\n\n\n3. songyang数据集  BARTLab-UCD论文链接：https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=10424680#page=6.48\n数据集链接：https://github.com/BRATLab-UCD/Radiomap-Data\ndropbox：https://www.dropbox.com/scl/fo/kua86qnk1aukt8i4f2rma/h?rlkey=j82kiq4dgaw3l0bzbeyfvv4oi&amp;e=1&amp;dl=0\n裁剪版本：\n​\t18:\n​\t\t&#x2F;data&#x2F;home&#x2F;dcy&#x2F;SR&#x2F;change&#x2F;Supreme-master&#x2F;dataset&#x2F;train.npy\n​\t17:\n​\t\t&#x2F;data&#x2F;home&#x2F;dcy&#x2F;diffusion&#x2F;spilt_scene\n​\t\t&#x2F;data&#x2F;home&#x2F;dcy&#x2F;diffusion&#x2F;stations_v1\n​\t\t&#x2F;data&#x2F;home&#x2F;dcy&#x2F;diffusion&#x2F;buildings_v1\n4. 小规模高保真数据集  JHU-Lab论文链接：https://ieeexplore.ieee.org/abstract/document/10424680\n5. radiomapseerRadioUNet: Fast Radio Map Estimation With Convolutional Neural Networks\n数据集说明：\n​\tRadioMapSeer数据集由700张地图组成，每张地图80个发射机位置，以及相应的粗略模拟无线电地图。 粗略的模拟是使用主导路径模型（DPM）方法[26]和智能光线追踪（IRT）[53]生成的，该方法基于光线与几何形状的2种相互作用，这里称为IRT2。 此外，我们还对每个地图的前两个发射器使用具有4个相互作用的IRT （IRT4）生成了精细模拟。 这些城市地图取自OpenStreetMap[54]，分别位于安卡拉、柏林、格拉斯哥、卢布尔雅那、伦敦和特拉维夫。 我们将发射机、接收机和建筑物的高度分别设置为1.5m、1.5m和25m，这与设备对设备的场景有关（详见III-B节）。 所有模拟均使用WinProp[38]软件进行计算。 对于不同的情况（例如，校园网，蜂窝网络），应该相应地生成新的数据集。 来自数据集的一些示例无线电地图如图1所示。 所有模拟都保存为256 × 256 m2二维网格中无线电地图的密集采样。\n\n粗略模拟无线电图：利用无线网络规划软件WinProp[38]，采用DPM和IRT2生成无线电图。 每个模拟无线电图在每个像素上存储像素位置和发射机位置之间的路径损耗（以dB为单位）。为了表示数据集中的不确定性，我们考虑两种情况。 首先，使用DPM和IRT2对包括汽车在内的所有城市地图进行一组模拟。 这些模拟是对仅基于城市地图的模拟的扰动，没有汽车。 此外，我们还提供了单独的扰动城市地图数据集，其中原始数据集的每张地图中都缺少m个建筑物。 我们提供了四个这样的数据集，m &#x3D;1，… 4。\n\n更高精度的模拟：使用IRT4与相同的WinProp无线网络规划软件提供了额外的更小的更高精度模拟数据集。 在这里，我们为700张地图中的每张地图考虑了两个发射机位置。 更高精度模拟的目标是提供一种方法来测试经过模拟训练的网络是否在路径损失函数的精细表示中表现良好。 如前所述，我们在这里重申，高精度模拟可以替代现实生活中的物理现象，它有助于证明我们方案的可转移性。\n\n路径损耗尺度：将路径损耗值PL转换为0 ~ 1之间的灰度像素值（见第III-C节）。 因此，每个无线电地图都是一个大小为256 × 256的灰度级图像。\n\n\n\n参数说明：\n​\t本研究最初是由智能交通系统（ITS）背景下的设备对设备安全通信驱动的，目前基于IEEE 802.11p标准。 因此，我们认为5.9GHz频段的信号带宽W为10MHz。 我们选择发射机功率和热噪声功率谱密度分别为（PTx）dB &#x3D; 23dBm和（N0）dB &#x3D; - 174dBm&#x2F;Hz，符合IEEE 802.11p标准，并假设接收机的理想噪声系数为0dB（参见图1(e)给出了系统参数的总结）。\n","categories":["radio map dataset"],"tags":["dataset"]},{"title":"深度学习相关笔记","url":"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/","content":"优化器Adam : Adaptive Moment Estimation特点：\n\n自适应学习率：每个参数都有自己的学习率\n带偏差修正：初期收敛更稳定\n\n缺点：正则化效果不好，L2 weight decay 实际上是“对梯度加衰减”，不是真正正则化参数\nAdamW : Adam + 正确的 Weight DecayAdam 里 L2 weight decay 是和梯度混合的 → 实际上是“修改梯度”，容易影响动量\n&#x3D;&#x3D;&gt; AdamW 把 weight decay 独立应用在参数更新上\n优点：\n\n正则化更纯粹 → 提高泛化能力\n训练更稳定 → 常用于 Transformer 和大模型\n\n💡 总结一句话：AdamW 就是带正确 L2 正则的 Adam\nLAMB : Layer-wise Adaptive Moments optimizer for Batch training &#x3D;&#x3D;&gt; 为大 batch &#x2F; 大模型训练设计的 AdamW 变体\nLayer-wise 自适应缩放: 每一层的参数更新 \\Delta \\theta 按比例缩放\n\n&#x3D;&#x3D;&gt; 解决大 batch 时学习率不均衡的问题\n\n保留 AdamW 的优点：偏差修正 + weight decay 独立\n\n特点：\n\n适合大 batch 训练（比如 BERT 或 GPT 大模型训练）\n学习率可以更大，收敛稳定\n对小模型、小 batch 不一定比 AdamW 有优势\n\nAdam&#x2F;SGD 的问题：在大 batch 训练时，直接放大学习率会导致震荡甚至不收敛。\nLAMB 的改进：\n\n它不仅像 Adam 一样对梯度做自适应缩放，还对 参数本身的范数 做归一化。\n换句话说，它确保“更新步长”和“参数大小”是成比例的，避免某些参数更新过大&#x2F;过小。\n\n这让 大 batch 训练时依然能稳定收敛，并且允许用更大学习率，加速训练\n总结：\n优化器会动态调整 步长（学习率）：\n\nSGD：固定学习率，单纯往梯度方向走。\nAdam：用一阶（均值）和二阶（方差）矩估计，对每个参数自适应调节学习率（大梯度 → 缩小步长，小梯度 → 放大学习率）。\nAdamW：在 Adam 基础上修正 weight decay 逻辑，让正则化效果更纯粹。\n学习率调度器（Scheduler）：额外定义随训练过程变化的学习率（warmup、cosine decay 等）。\n\n正则化定义：在模型训练时，加上一个约束，让它不要随意拟合训练数据，从而提高泛化能力。\n\n没正则化 → 模型可能过拟合 → 在训练集上很好，但测试集上表现差\n正则化 → 给模型“穿上枷锁”，让它学到更平滑、更简单的规律\n\n数学解释：在原本的损失函数上添加一个惩罚项\nL2 正则（Ridge &#x2F; Weight Decay）公式：\n\n特点：\n\n惩罚参数的平方 → 大参数会被压小\n对所有参数平滑地缩小 → 模型参数分布更均匀\n在优化器里对应 weight decay\n\n直观理解：\n\n想象每个参数是一根弹簧，L2 惩罚让弹簧尽量不要伸得太长\n模型不敢过度依赖某个特征 → 泛化能力强\n\n为什么大参数被压缩，模型不依赖单个特征？\n\n假设某个特征的权重大 → 它在预测中起决定性作用\nL2 正则会把所有权重都缩小 → 大权重被拉小 → 模型不能只依赖它\n\n结果：\n\n模型分布在更多参数上 → 特征利用更均衡\n泛化能力提升，不会因为训练集某个特征异常而过拟合\n\nL1 正则（Lasso）公式：\n\n特点：\n\n惩罚参数绝对值\n会产生 稀疏解 → 很多参数被压到 0\n可以做特征选择：保留重要特征，忽略不重要特征\n\n直观理解：\n\n想象把每根参数的长度直接砍掉一部分 → 不重要的直接砍成 0\n\n特点：\n\n梯度在 0 附近不连续 → 很容易把小参数直接压为 0\n重要参数保留 → 0 的参数对应“不重要”特征被忽略\n\n所以：\n\n稀疏解 &#x3D; 自动选择特征\n模型只保留对预测贡献大的特征\n\n补充：参数 梯度 权重 学习率\n权重（weight）：就是模型里的参数。\n\n模型学习的核心目标就是找到一组最优权重，使得预测结果和真实标签尽可能接近。\n\n梯度（gradient）：损失函数对权重的导数（往哪走）\n\n它告诉我们：如果我稍微调整某个权重，损失会往哪个方向增大&#x2F;减小。\n所以梯度本质上是更新权重的方向指引器，而不是权重本身。\n\n学习率：控制“步长”，在梯度更新和正则化中都起作用（走的步长）\n\n控制梯度下降和正则化压缩的步长\n学习率衰减：随训练逐步减小 \\eta\n\n初期大步 → 快速下降\n\n后期小步 → 收敛稳定\n\n作用于梯度和正则化一起，避免收敛振荡\n\n\n梯度下降：根据梯度调整参数\n正则化：在损失函数中加上了一项，求导之后权重更新中多了一项正则项对梯度的贡献\nweight decay：不从梯度计算，直接对参数进行衰减 &#x3D;&#x3D;&gt; 避免和动量&#x2F;自适应梯度混合干扰，数值表现更稳定（这就是 AdamW 的核心改进 –&gt; 把两者区分开）。\n优化器中的weight decayWeight Decay 就是 L2 正则化在优化器里的实现方式\n传统做法：在更新参数的时候直接加上对参数的惩罚\n\n\n优化器中的正则化通常只有 L2（Weight Decay）。L1 可以自己手动加到损失函数里，但主流优化器（AdamW、LAMB、SGD）默认只支持 L2&#x2F;Weight Decay\n有些场景会混合使用（比如 Elastic Net &#x3D; L1 + L2）\n权重（参数）更新权重（参数）更新是 梯度 + 正则化 + 优化器机制 共同作用的结果：\n\n梯度：来自损失函数 \\mathcal{L}，告诉你该往哪走、走多远（方向 + 大小）。\n正则化：相当于在损失函数里加“惩罚项”，限制参数规模或稀疏化（L1&#x2F;L2），避免模型太复杂。\n优化器：在用梯度更新参数时，额外引入技巧（动量、学习率调度、权重衰减等），让训练更快、更稳。\n\n你可以把它想成：梯度是指路灯，正则化是修路时加的护栏，优化器是导航软件，三者一起决定你怎么走到终点。\n随机种子在深度学习里很多东西都带“随机性”：\n\n数据打乱（shuffle&#x3D;True 时，每个 epoch 样本顺序会随机变化）\n参数初始化（模型的权重通常用随机数初始化）\nDropout（每次会随机丢掉不同的神经元）\n数据增强（随机裁剪、翻转等）\n\n如果不设种子，每次运行都会不一样，结果可能波动很大。\n&#x3D;&#x3D;&gt; 设定随机种子 &#x3D; 固定“随机数生成器”的起点，保证你下次跑出来的结果和这次一样（复现实验）。\n","categories":["基础知识","深度学习"],"tags":["notes"]},{"title":"开发相关资料整理","url":"/%E4%BB%93%E5%BA%93/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/","content":"推荐课周志明的软件架构课（构筑大型的可靠软件系统）：https://time.geekbang.org/opencourse/intro/100064201\n推荐书设计数据密集型应用：（中文翻译版）https://github.com/Vonng/ddia\n产品调研网站参考掘金、知乎、牛客、百度贴吧\n开发者客栈：https://github.com/Qbian61/forum-java\n链滴：https://github.com/88250/symphony\npybbs：https://github.com/tomoya92/pybbs\nlearnku：https://learnku.com/articles/40839\n黑客说：https://hackertalk.net/\n设计软件搞定设计：https://www.gaoding.com\ncanva：https://www.canva.cn\n工程实现DB相关数据库表自动初始化（Liquibase）​\thttps://www.yuque.com/itwanger/az7yww/wo81a7zngcim6wvb\n​\thttps://spring.hhui.top/spring-blog/2022/12/21/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-DataSourceInitializer%E6%96%B9%E5%BC%8F/\n​\thttps://spring.hhui.top/spring-blog/2022/12/21/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-jpa%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/\n​\thttps://spring.hhui.top/spring-blog/2022/12/21/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-DataSourceInitializer%E6%96%B9%E5%BC%8F/\n","categories":["仓库"],"tags":["整理","资源"]},{"title":"高并发场景解决方案细粒度实例","url":"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%BC%80%E5%8F%91/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%BB%86%E7%B2%92%E5%BA%A6%E5%AE%9E%E4%BE%8B/","content":"数据库表中有一个字段会频繁更新（比如递增）这时你可以：\n\n先查询，如果存在就更新，如果不存在就初始化\n用一条SQL完成插入和更新，无需先查询（利用id和type的唯一索引）\n\n-- 核心SQL：如果记录存在则 cnt+1，不存在则初始化 cnt=1INSERT INTO read_count (document_id, document_type, cnt)VALUES (101, 1, 1)ON DUPLICATE KEY UPDATE cnt = cnt + 1;\n\n原理：因为 idx_document_id_type 是唯一索引，当插入的 (document_id, document_type) 已存在时，会触发 **ON DUPLICATE KEY UPDATE**，执行 cnt = cnt + 1；\n优势：原子性操作，避免并发下的 “查询 - 更新” 不一致问题，性能更高。\n注意：用递增的方式而不是赋值的方式 &#x3D;&#x3D;&gt; 并发请求下保证计数准确（如果赋值可能会出现覆盖更新的问题）\n其他优化思路：\n缓冲层缓冲：用**redis做计数缓冲（还可以用来做uv统计**），再定时把redis的值批量同步到redis\n异步更新：计数请求放到消息队列中，后台的消费队列再批量更新数据库，不用阻塞等待请求\n分库分表：如果单表数据量太大了，可以按照document_type分表，或者按照document_id哈希分表，分散写入压力\n\n","categories":["基础知识","开发"],"tags":["开发","高并发","实例"]},{"title":"文章整理","url":"/%E4%BB%93%E5%BA%93/%E6%96%87%E7%AB%A0%E6%95%B4%E7%90%86/","content":"IEEE Communications Surveys &amp; Tutorials 调研 – RM\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n序号\n名称\n期刊&#x2F;会议\n年份\n网络结构\n代码地址\n补充\n参数量\n引用量\nnotes\n\n\n1\nA Tutorial on Environment-Aware Communications via Channel Knowledge Map for 6G\nIEEE Communications Surveys &amp; Tutorials\n2024\n\n\n曾勇老师的文章\n\n\n环境感知的CKM\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2\nSurvey on Near-Space Information Networks: Channel Modeling, Transmission, and Networking Perspectives\nIEEE Communications Surveys &amp; Tutorials ( Early Access )\n2025\n\n\n分析了高空（无人机）和近地空间的信道建模方法区别\n\n\n\n\n\n3\nTerahertz Channel Propagation Phenomena, Measurement Techniques and Modeling for 6G Wireless Communication Applications: A Survey, Open Challenges and Future Research Directions\nIEEE Communications Surveys &amp; Tutorials\n2022\n\n\n太赫兹信道建模\n\n\n\n\n\n4\nA Tutorial on NYUSIM: Sub-Terahertz and Millimeter-Wave Channel Simulator for 5G, 6G, and Beyond\nIEEE Communications Surveys &amp; Tutorials\n2024\n\n\n关注某一种信道建模方法（统计型信道建模方法）\n\n\n\n\n\n其他\n\n\n\n\n\n\n\n\n\n\n\n\nA Survey on Channel Estimation and Practical Passive Beamforming Design for Intelligent Reflecting Surface Aided Wireless Communications\nIEEE Communications Surveys &amp; Tutorials\n2022\n\n\n使用某种方法设计IRS元件配置，通过测CSI，然后控制反射，提升通信质量\n\n\n\n\n\n\nA Survey of Indoor Localization Systems and Technologies\nIEEE Communications Surveys &amp; Tutorials\n2019\n\n\n室内定位技术调查\n\n\n\n\n\n\nLarge Language Model (LLM) for Telecommunications: A Comprehensive Survey on Principles, Key Techniques, and Opportunities\nIEEE Communications Surveys &amp; Tutorials\n2025\n\n\n应用在通信领域的大模型方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n理论型文章\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n序号\n名称\n期刊&#x2F;会议\n年份\n网络结构\n代码地址\n补充\n参数量\n引用量\nnotes\n\n\n1\nRadio Map Estimation Based on Generative Artificial Intelligence: Evolution from Point-Level to Cell-Level Prediction\nIEEE Communications Magazine\n2025\n\n\n\n\n\n\n\n\n2\nAdvancing Ubiquitous Wireless Connectivity Through Channel Twinning\nIEEE Communications Magazine\n2025\n\n\n\n\n\n\n\n\n3\nTheoretical Analysis of the Radio Map Estimation Problem\nTWC\n2024\n\n\n\n\n\n\n\n\nSheet3\n\n\n多模态大模型文章\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n序号\n名称\n期刊&#x2F;会议\n年份\n作者\n单位\n网络结构\n代码地址\n补充\n参数量\n引用量\nnotes\n\n\n1\nBLIP: Bootstrapping Language-Image Pre-training for Unified Vision-Language Understanding and Generation\nPMLR\n2022\n\n\n\nhttps://github.com/salesforce/BLIP\n\n\n\n\n\n\nDiffusion\n\n\n\n\n\n\n\n\n\n\n\n\n\n序号\n名称\n期刊&#x2F;会议\n年份\n\n单位\n网络结构\n代码地址\n补充\n参数量\n引用量\nnotes\n\n\n1\nDenoising Diffusion Probabilistic Models\nNIPS\n2020\n\n\nDDPM\nhttps://github.com/hojonathanho/diffusion\n（应该是）DDPM的原始论文\n\n\n\n\n\n2\nHigh-Resolution Image Synthesis with Latent Diffusion Models\nCVPR\n2022\n\n\n在潜在空间VAE内做diffusion\nhttps://github.com/CompVis/latent-diffusion\n\n\n\n\n\n\n3\nScalable Diffusion Models with Transformers\nICCV\n2023\n\n\nunet换成transformer\n无\n\n\n\n\n\n\n4\nAdaptive Latent Diffusion Model for 3D Medical Image to Image Translation: Multi-modal Magnetic Resonance Imaging Study\nWACV\n2024\n\n\n\nhttps://github.com/jongdory/ALDM/\n\n\n\n\n\n\n\nradiomap调研\n\n\n\n\n\n\n\n\n\n\n\n\n序号\n名称\n期刊&#x2F;会议\n年份\n作者\n单位\n网络结构\n代码地址\n补充\n参数量\n引用量\nnotes\n\n\n1\nWiFi-Diffusion: Achieving Fine-Grained WiFi Radio Map Estimation with Ultra-Low Sampling Rate by Diffusion Models\nJSAC\n2025\nZhiyuan Liu, Shuhang Zhang , Qingyu Liu, Hongliang Zhang , Lingyang Song\n\n\n只有数据集链接\n\n\n\n\n\n\n2\nTiRE-GAN: Task-Incentivized Generative Learning for Radiomap Estimation\nWCL\n2025\n\n\n\n无\n\n\n\n\n\n\n3\nMFFGCN: Multimodal Feature Fusion Graph Convolution Network for Radio Map Estimation with Uneven Spatial Sampling\nTMC\n2025\n\n\n\n无\n多模态特征融合图卷积网络的\n\n\n\n\n\n非均匀空间采样\n\n\n\n\n\n\n\n\n\n\n\n\n\n4\nLightweight and Self-Evolving Channel Twinning: An Ensemble DMD-Assisted Approach\nTWC\n2025\n\n\n\n无\n轻量级和自进化信道孪生\n\n\n\n\n\n集成dmd辅助方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n5\nHigh-Efficiency Urban 3D Radio Map Estimation Based on Sparse Measurements\nTVT\n2025\n\n\n\n无\n\n\n\n\n\n\n6\nGPRT: A Gaussian Process Regression-Based Radio Map Construction Method for Rugged Terrain\nIoTJ\n2025\n\n\n\n\n高斯回归过程\n\n\n\n\n\n7\nGEO2SIGMAP: High-Fidelity RF Signal Mapping Using Geographic Databases\nDySPAN\n2024\n\n\n\nhttps://github.com/functions-lab/geo2sigmap\n不是那种代码反正\n\n\n\n\n\n8\nGeo2ComMap: Deep Learning-Based MIMO Throughput Prediction Using Geographic Data\nWCL\n2025\n\n\n\nhttps://github.com/geo2commap/Geo2ComMap\n和上面一个系列的\n\n\n\n\n\n9\nRadioGAT: A Joint Model-Based and Data-Driven Framework for Multi-Band Radiomap Reconstruction via Graph Attention Networks\nTWC\n2024\n\n\n图神经网络\n\nsongyang zhang\n\n\n\n\n\n10\nRadioMamba: Breaking the Accuracy-Efficiency\n\n\n\n\n\n\n\n\n\n\n\n\nTrade-off in Radio Map Construction via a Hybrid\n\n\n\n\n\n\n\n\n\n\n\n\n\nMamba-UNet\narxiv\n2025\nHonggang Jia, Nan Cheng, Xiucheng Wang, Conghao Zhou, Ruijin Sun, Xuemin (Sherman) Shen\n\nmamba\n无\n\n\n\n\n\n\n\n11\n3D-RadioDiff: An Altitude-Conditioned Diffusion Model\n\n\n\n\n\n\n\n\n\n\n\n\nfor 3D Radio Map Construction\nWCL\n2025\nLe Zhao , Zesong Fei, Xinyi Wang, Jihao Luo , and Zhong Zheng\n\n\n无\nå\n\n\n\n\n\n\n12\nRadioDiff: An Effective Generative Diffusion\n\n\n\n\n\n\n\n\n\n\n\n\nModel for Sampling-Free Dynamic Radio\n\n\n\n\n\n\n\n\n\n\n\n\n\nMap Construction\nTCCN\n2025\nXiucheng Wang, Keda Tao, Nan Cheng , Zhisheng Yin ,Zan Li , Yuan Zhang ,and Xuemin Shen\n\n\nhttps://github.com/UNIC-Lab/RadioDiff\n\n\n\n\n\n\n\n13\nRMDM: Radio Map Diffusion Model with Physics Informed\narxiv\n2025\nHaozhe Jia , Wenshuo Chen , Zhihui Huang , Hongru Xiao, Nanqian Jia , Keming Wu, Songning Lai , Yutao Yue\n\ndiffusion + PINN\nhttps://github.com/Hxxxz0/RMDM\n\n\n\n\n\n\n14\nPhysics-informed neural network (pinn) evolution and be-\n\n\n\n\n\n\n\n\n\n\n\n\nyond: A systematic literature review and bibliometric\n\n\n\n\n\n\n\n\n\n\n\n\n\nanalysis\n\n2022\nZaharaddeen Karami Lawal, Hayati\n\n\n\n\n\n\n\n\n\n\nYassin, Daphne Teck Ching Lai, and Azam Che Idris\n\nPINN\n\n\n\n\n\n\n\n\n\n\n\n15\nTHE SAMPLING-ASSISTED PATHLOSS RADIO MAP PREDICTION COMPETITION\n\n\n\n\n\n\n一篇竞赛文章\n\n\n\n\n\n1\nUpdating radio maps without pain: An enhanced transfer learning approach\nJIOT\n2021\n\n\n\n无\n迁移学习\n\n\n\n\n\n2\nCell-level rsrp estimation with the image-to-image wireless propagation model based on measured data\nTCCN\n2023\n\n\n\nhttps://github.com/ZhengSaber/Cell-Level-RSRP-Estimation\nPix2pix\n\n\n\n\n\n3\nDeep completion autoencoders for radio map estimation\nTWC\n2021\n\n\n\nhttps://github.com/yvestegnya2/deepautoencoders-cartography\nAE\n\n\n\n\n\n\n中文文献\n\n\n\n\n\n\n\n\n\n\n\n\n序号\n名称\n期刊&#x2F;会议\n年份\n作者\n单位\n网络结构\n代码地址\n补充\n参数量\n引用量\nnotes\n\n\n1\nAI使能的信道知识地图高效构建与应用\n移动通信\n2024年8月第8期\n吴迪 1，曾勇 1,2**\n1.东南大学移动通信全国重点实验室, 江苏 南京 210096；2.紫金山实验室，江苏 南京 211111\n\n\n\n\n\n\n\n\n2\n基于智能射线追踪的信道计算与半实物仿真\n电波科学报\n45289\n刘煜鑫 1,2 何丹萍 2* 单馨漪 1,2 费丹 1,2官科 1,2郭兰图 3\n（1. 北京交通大学 先进轨道交通自主运行全国重点实验室，北京 100044；2. 北京交通大学电子信息工程学院，北京100044；3. 中国电波传播研究所，青岛 266107\n\n\n\n\n\n\n\n\n3\n基于不确定性感知的多智能体主动式无线电地图估计\n电子科技大学学报\n45901\n张蕴霖，邵晋梁*，陈    凯，程玉华，李铁山\n电子科技大学\n\n\n采样轨迹优化\n\n\n\n\n\n4\n基于差分卷积和注意力机制的无线电地图构建方法研究\n电波科学学报\n45689\n谭海东，杨晶晶，黄铭\n1. 云南大学 信息学院，昆明 650091；2. 云南大学无线创新实验室，昆明 650091\n\n\n\n\n\n\n\n\ncontrolnet\n\n\n\n\n\n\n\n\n\n\n\n\n\n序号\n名称\n期刊&#x2F;会议\n年份\n作者\n单位\n网络结构\n代码地址\n补充\n参数量\n引用量\nnotes\n\n\n1\nAdding Conditional Control to Text-to-Image Diffusion Models\nICCV\n2023\nLvmin Zhang, Anyi Rao, and Maneesh Agrawala\n\n\n\n\n\n\n\n\n\nStanford University\n\n\nhttps://github.com/lllyasviel/ControlNet/tree/main\ncontrolnet 提出\n\n\n\n\n\n\n\n\n\n2\nCRS-Diff: Controllable Remote Sensing Image Generation with Diffusion Model\nTGRS\n2024\nDatao Tang; Xiangyong Cao; Xingsong Hou; Zhongyuan Jiang; Junmin Liu; Deyu Meng\n\n\nhttps://github.com/Sonettoo/CRS-Diff\ncontrolnet 应用\n\n\n\n\n\n生成多图\n\n\n\n\n\n\n\n\n\n\n\n\n\n3\nGenerate Your Own Scotland: Satellite Image Generation Conditioned on Maps\narxiv\n2023\n\n\n\nhttps://github.com/toastyfrosty/map-sat\ncontrolnet 应用\n\n\n\n\n\n生成多图\n\n\n\n\n\n\n\n\n\n\n\n\n\nmamba\n\n\n\n\n\n\n\n\n\n\n\n\n\n序号\n名称\n期刊&#x2F;会议\n年份\n作者\n单位\n网络结构\n代码地址\n补充\n参数量\n引用量\nnotes\n\n\n1\nRadioMamba: Breaking the Accuracy-Efficiency\n\n\n\n\n\n\n\n\n\n\n\n\nTrade-off in Radio Map Construction via a Hybrid\n\n\n\n\n\n\n\n\n\n\n\n\n\nMamba-UNet\narxiv\n2025\nHonggang Jia, Nan Cheng, Xiucheng Wang, Conghao Zhou, Ruijin Sun, Xuemin (Sherman) Shen\n\nmamba\n无\n\n\n\n\n\n\n\n2\nVision Mamba: Efficient Visual Representation Learning with Bidirectional State Space Model\nICML\n2024\n\n\n视觉 mamba\nhttps://github.com/hustvl/Vim\n\n\n\n\n\n\n3\nDiM: Diffusion Mamba for\n\n\n\n\n\n\n\n\n\n\n\n\nEfficient High-Resolution Image Synthesis\narxiv\n2024\n\n\nmamba + diffusion\nhttp://github.com/tyshiwo1/DiM-DiffusionMamba/\n\n\n\n\n\n\n\n4\nDimba: Transformer-Mamba Diffusion Models\narxiv\n2024\n\n\n\nhttps://github.com/feizc/Dimba\n\n\n\n\n\n\n5\nA Mamba-Diffusion Framework for Multimodal Remote Sensing\n\n\n\n\n\n\n\n\n\n\n\n\nImage Semantic Segmentation\n一个letter\n2024\n\n\n\nhttps://github.com/WenliangDu/MambaDiffusion\n\n\n\n\n\n\n\n6\nU-shaped Vision Mamba for Single Image\n\n\n\n\n\n\n\n\n\n\n\n\nDehazing\narxiv\n2024\n\n\nunet + mamba\nhttps://github.com/zzr-idam\n文章：物理信息引导-8-多路径xx这篇文章用作对比实验\n\n\n\n\n\n\n物理信息引导\n\n\n\n\n\n\n\n\n\n\n\n\n\n序号\n名称\n期刊&#x2F;会议\n年份\n作者\n单位\n网络结构\n代码地址\n补充\n参数量\n引用量\nnotes\n\n\n1\nRMDM: Radio Map Diffusion Model with Physics Informed\narxiv\n2025\nHaozhe Jia , Wenshuo Chen , Zhihui Huang , Hongru Xiao, Nanqian Jia , Keming Wu, Songning Lai , Yutao Yue\n\ndiffusion + PINN\nhttps://github.com/Hxxxz0/RMDM\n\n\n\n\n\n\n2\nPhysics-informed neural network (pinn) evolution and be-yond: A systematic literature review and bibliometric\n\n\n\n\n\n\n\n\n\n\n\n\nanalysis\n\n2022\nZaharaddeen Karami Lawal, Hayati\n\n\n\n\n\n\n\n\n\n\nYassin, Daphne Teck Ching Lai, and Azam Che Idris\n\nPINN\n\n\n\n\n\n\n\n\n\n\n\n3\nPhysics-Informed Neural Networks for Path Loss Estimation by Solving Electromagnetic Integral Equations\nTWC\n2024\nFenyu Jiang , Tong Li , Xingzai Lv , Hua Rui, and Depeng Jin\nDepartment of Electronic Engineering\n\n\n\n\n\n\n\n\nTsinghua University\n体积分方程\n无\n\n\n\n\n\n\n\n\n\n\n\n4\nPhysics-Informed Representation Alignment for Sparse Radio-Map Reconstruction\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n&#x2F;&#x2F;\n\n和RMDM是同一个工作\n\n\n\n\n\n\n\n5\nRadioDUN: A Physics-Inspired Deep Unfolding Network for Radio Map\n\n\n\n\n\n\n\n\n\n\n\n\nEstimation\narxiv\n2025\nTaiqin Chen, Zikun Zhou, Zheng Fang, Wenzhen Zou, Kangjun Liu, Ke Chen, Yongbing Zhang, Yaowei Wang\n\n\n\n\n\n\n\n\n\n\n6\nPINN and GNN-based RF Map Construction for Wireless Communication Systems\narxiv\n2025\nLizhou Liu, Xiaohui Chen, Zihan Tang, Mengyao Ma, Wenyi Zhang\n1Department of Electronic Engineering and Information Science,\n\n\n\n\n\n\n\n\nUniversity of Science and Technology of China, Hefei, Anhui 230027, China2Wireless Technology Lab, Huawei, Shenzhen 518129, China\n\n\n\n\n\n\n\n\n\n\n\n\n\n7\nReVeal: A Physics-Informed Neural Network for High-Fidelity Radio Environment Mapping\nDySPAN\n2025\nMukaram Shahid; Kunal Das; Hadia Ushaq; Hongwei Zhang; Jiming Song; Daji Qiao\nIowa State University\n\n\n\n\n\n\n\n\nAmes, IA, USA\n\n\n\n\n\n\n\n\n\n\n\n\n\n8\nMulti-Path Aware Radio Map Construction for 6G Environment-Aware Communication: A Helmholtz Equation-Informed Approach\nICCC\n2025\nXiucheng Wang; Peilin Zheng; Nan Cheng; Conghao Zhou; Ruijin Sun; Guiyang Luo\nState Key Laboratory of ISN and School of Telecommunications Engineering, Xidian University, Xi’an, 710071, China\n\n\n\n\n\n\n\n\n†School of Computer Science and Technology, Beijing University of Posts and Telecommunications, Beijing, China\n\n\n\n\n\n\n\n\n\n\n\n\n\n‡ Department of Electrical and Computer Engineering, University of Waterloo, Waterloo, ON N2L 3G1, Canada\n\n\n\n\n\n\n\n\n\n\n\n\n\n9\nPhysics-Informed Neural Networks for Pathloss Prediction\nMLSP\n2023\nSteffen Limmer, Alberto Martinez Alba, Nicola Michailow\nSiemens AG, Technology, Otto-Hahn-Ring 6, 81739 Munich, Germany\n让神经网络输出拟合物理函数\n\n\n\n\n\n\n\n10\nA More General Electromagnetic Inverse Scattering Method Based on Physics-Informed Neural Network\nTGRS\n2023\nYi-Di Hu, Xiao-Hua Wang, Hui Zhou , Lei Wang, Bing-Zhong Wang\n\n不是作为损失函数引导\n\n\n\n\n\n\n\n11\nRADIOLUNADIFF: ESTIMATION OF WIRELESS NETWORK SIGNAL STRENGTH IN LUNAR TERRAIN\narxiv\n2025\nPaolo Torrado1, Anders Pearson1, Jason Klein2, Alexander Moscibroda3 and Joshua Smith1\n1University of Washington, 2Cornell University, 3The Bear Creek School\n网络预测k2图\n\n\n\n\n\n\n\n审稿意见\n\n\n\n\n\n\n\n\n\n\n\n\n\n序号\n名称\n期刊&#x2F;会议\n年份\n作者\n单位\n网络结构\n代码地址\n补充\n参数量\n引用量\nnotes\n\n\n1\nREM-U-Net_Deep_Learning_Based_Agile_REM_Prediction_With_Energy-Efficient_Cell-Free_Use_Case\nIEEE Open Journal of Signal Processing\n2024\nHAZEM SALLOUHA 1,2 (Member, IEEE), SHAMIK SARKAR 2 (Member, IEEE), ENES KRIJESTORAC 2, AND DANIJELA CABRIC 2 (Fellow, IEEE)\n1Department of Electrical Engineering, KU Leuven, 3000 Leuven, Belgium 2Department of Electrical and Computer Engineering, University of California, Los Angeles, Los Angeles, CA 90095 USA\n\n\n\n\n\n\n\n\n2\nQuantized Radio Map Estimation Using Tensor and Deep Generative Models\nIEEE TRANSACTIONS ON SIGNAL PROCESSING\n2024\nSubash Timilsina , Sagar Shrestha ,and Xiao Fu\n\n\n\n\n\n\n\n\n\n1\nTransformer based Radio Map Prediction Model for Dense Urban Environments\n2021 13th International Symposium on Antennas, Propagation and EM Theory (ISAPE)\n2021\nYu Tian; Shuai Yuan; Weisheng Chen; Naijin Liu\n中国空间技术研究院\nTransformer\nhttps://github.com/QXSLAB/RadioTrans_Official\n\n\n\n\n\n\ndiffusion 全家桶\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRadioDiff-Inverse: Diffusion Enhanced Bayesian Inverse Estimation for ISAC Radio Map Construction\narxiv\n2025\nXiucheng Wang, Zhongsheng Fang, Nan Cheng, Ruijin Sun, Zan Li, Xuemin (Sherman)Shen\n\nhttps://arxiv.org/pdf/2504.14298\nhttps://github.com/UNIC-Lab/iRadioDiff\n\n\n\n\n\n\n\niRadioDiff: Physics-Informed Diffusion Model for Indoor Radio Map Construction and Localization\narxiv\n2025\nXiucheng Wang, Tingwei Yuan, Yang Cao, Nan Cheng, Ruijin Sun, Weihua Zhuang\n\nhttps://arxiv.org/abs/2511.20015\n\n\n\n\n\n\n\n\nRadioDiff-Turbo: Lightweight Generative Large Electromagnetic Model for Wireless Digital Twin Construction\nINFOCOM WKSHPS\n2025\nXiucheng Wang; Peilin Zheng; Nan Cheng; Ruijin Sun; Junting Chen; Keda Tao\n\nhttps://ieeexplore.ieee.org/abstract/document/11152929\n\n\n\n\n\n\n\n\nDenoising Diffusion Probabilistic Model for Radio Map Estimation in Generative Wireless Networks\nTCCN\n2025\nXuanhao Luo; Zhizhen Li; Zhiyuan Peng; Mingzhe Chen; Yuchen Liu\n\nhttps://ieeexplore.ieee.org/abstract/document/10843401\n\n\n\n\n\n\n\n\nHigh-Efficiency Urban 3D Radio Map Estimation Based on Sparse Measurements\nTVT\n2025\nXinwei Chen; Xiaofeng Zhong; Zijian Zhang; Linglong Dai; Shidong Zhou\n\nhttps://ieeexplore.ieee.org/abstract/document/11015096\n\n\n\n\n\n\n\n\nRadio Map Estimation Based on Generative Artificial Intelligence: Evolution from Point-Level to Cell-Level Prediction\nMCOM\n2025\nYi Zheng; Ji Wang; Wenwu Xie; Xingwang Li; Shahid Mumtaz; Anwer Al-Dulaimi\n\nhttps://ieeexplore.ieee.org/abstract/document/10974726\n\n\n\n\n\n\n\n\nLeveraging Transfer Learning for Radio Map Estimation via Mixture of Experts\nTCCN\n2025\nRahul Kumar Jaiswal; Mohamed Elnourani; Siddharth Deshmukh; Baltasar Beferull-Lozano\n\nhttps://ieeexplore.ieee.org/abstract/document/11005396\n\n\n\n\n\n\n\n","categories":["仓库"],"tags":["整理","资源"]},{"title":"\"Frequency Domain-Based Diffusion Model for Unpaired Image\" Dehazing","url":"/papers/work2/papers/work2/postpapers-work2-Frequency-Domain-Based-Diffusion-Model-for-Unpaired-Image-Dehazing/","content":"基于频域的非配对图像去雾扩散模型\n图像去雾：从被雾霾遮挡的图像中恢复清晰图像。传统方法多依赖物理模型（如大气散射模型）或配对训练数据（清晰图像 + 对应雾图像）。\n\n输入：雾图像（Hazy Image）\n输出：去雾图像（Dehazed&#x2F;Clear Image）\n目标：恢复清晰图像的颜色、纹理和结构，同时去除雾霾造成的衰减和颜色偏移。在非配对设置下，你 不需要每个雾图像都对应一个清晰图像，训练数据更灵活：\n数据集只提供一组雾图像和一组清晰图像，但没有逐一对应关系。\n通常使用 生成对抗网络（GAN） 或 对比学习（Contrastive Learning） 来学习域间映射：\n雾域 → 清晰域\n保持图像内容不变，但去除雾霾特征“忽略了频域的雾霾特性（雾霾相关的退化主要表现在幅度谱上）”，这就涉及 图像频域分析：\n\n\n雾霾对图像主要表现为 低频衰减、高频模糊：\n幅度谱的低频部分（整体亮度和大结构）会被衰减或偏移\n高频部分（纹理、边缘）会模糊基于对比学习的主流方法如果只在 空间域（RGB像素或特征图） 对比，可能会 保留雾霾残余 或破坏纹理。\n\n\n\n\nabstruct非配对图像去雾（Unpaired image dehazing）因其在模型训练过程中对数据需求的灵活性而受到越来越多的关注。基于对比学习的主流方法不仅引入了与雾霾无关的内容信息，而且忽略了频域的雾霾特性（即雾霾相关的退化主要表现在幅度谱上）。为了解决这些问题，我们提出了一种新的基于频域的扩散模型，称为FrDiff，以充分利用非成对清晰数据中的有益知识。 特别是，受扩散模型强大的生成能力的启发，我们从频域重建的角度来解决去雾任务，并执行扩散模型以产生与清晰图像分布一致的幅度谱。为了实现这一目标，我们提出了一种振幅残差编码器（Amplitude Residual Encoder， ARE）来提取振幅残差，有效地补偿了模糊域到清晰域的振幅间隙，并为dm（diffusion model）的训练提供了监督。此外，我们提出了一种相位校正模块（PCM），通过使用简单的注意机制进一步细化除雾过程中的相位谱来消除伪影。实验结果表明，我们的FrDiff在合成和真实数据集上都优于其他最先进的方法。\nintro雾霾是一种经常发生的大气现象，是由粉尘、烟雾等气溶胶粒子的散射效应引起的。 它通常导致场景辐射衰减，产生严重的视觉内容退化[19]。 图像去雾可以用于提高后续高级视觉任务的性能[31,46]。为了消除雾霾，传统方法是基于大气散射模型[38]或观测值手动设计图像先验[3,4,18,19,68]。 然而，这些手工制作的先验很难准确地模拟雾霾的内在特征，而且往往缺乏鲁棒性和可靠性。 最近基于深度学习的方法主要集中在使用合成的成对模糊-清晰数据开发监督模型[13,34,42,42,64]。其中，亮度对比（如雾霾）表现在幅值谱上的发现[39,48]显示了通过频域去除雾霾的巨大潜力[30,41,62]（如图2(a)所示，详细的统计分析请参见附录）。 然而，合成雾霾与真实雾霾之间存在较大的域差距，限制了其在现实场景下的泛化能力[60]。 此外，获取成对的模糊清晰数据非常昂贵且耗时。最近，扩散模型（DMs）在图像恢复方面表现出了令人印象深刻的性能[10,24,32,36,59,61]，这促使我们研究它们在雾霾去除方面的有效性。\n\n图2。 (a)雾霾在频域的退化特性说明。 雾霾的降解可以通过振幅谱的交换进行转移。 \n(b)类对比学习方法构建正、负样本对，最大限度地提高干净图像和模糊图像之间的互信息。 \n(c)我们的FrDiff在训练过程中从未配对的数据中学习清晰图像的振幅谱，并在推理过程中重建它们。\n然而，将这些模型应用于非配对图像去雾存在一些挑战：\n1)dm对亮度对比度敏感。 直接利用DMs生成清晰图像的方法[24,36]往往会导致不可预测的伪影和色差，同时也会产生大量的计算成本[61,63]。 \n2)其他使用dm生成潜在表示的方法[10,32,59]只能从高质量的成对数据中学习，这限制了它们在非成对设置中的应用。 因此，探索利用DMs进行非配对图像恢复的有效方法仍然是一个重大挑战。\n本文针对雾霾的频域特征，提出了一种新的非配对图像去雾（FrDiff）扩散模型。 FrDiff的核心思想是利用DM学习从未配对的数据中重建清晰图像的振幅，如图2(c)所示。 \n具体来说，我们按照前面的实践[10,59]将FrDiff的训练过程分为两个步骤，如图3所示。 \n\n在第一步中，我们引入了振幅残差编码器（Amplitude Residual Encoder， ARE），它提取振幅残差来解决模糊图像和清晰图像之间振幅分布的差距，而不会干扰与雾无关的特征。 此外，我们在除雾网络中加入相位校正模块（PCM）以进一步增强相位谱。 我们对除雾网络进行了优化，以有效地利用振幅残差进行除雾。 \n在第二步中，我们利用从ARE获得的幅度残差作为地面真值，并训练DM从高斯噪声中重建这些残差以去除雾霾。 在推理过程中，DM以高斯噪声为输入，以模糊图像的幅值谱为条件重构幅值残差。 与重建包含光照和纹理结构的图像相比，重建只包含光照信息的幅值残差所需的迭代次数更少[39,48]。\n我们提出了一种新的基于频域的非配对图像去雾（FrDiff）扩散模型，这是第一个将DM集成到非配对恢复任务中的研究。\n\nFrDiff通过学习非配对数据的振幅重建来增强雾霾去除能力，为其他非配对恢复任务提供了灵感。\n\n\n我们提出了一个振幅残差编码器（ARE），它产生振幅残差，以弥合模糊和清晰域之间的差距，而不添加额外的参数，为DM训练提供监督。\n我们提出了一种相位校正模块（PCM），旨在通过使用注意机制改进相位谱来消除不需要的伪像。\n大量实验表明，FrDiff以更少的参数和FLOPs优于现有的SOTA方法。\n\n\n\n空间域vs频域\n\n空间域：平时可见的图像，由像素值矩阵表示，每个像素值直接表示亮度和颜色\n频域：将图像从像素表示转换成频域表示。频率表示图像中亮度变化的快慢\n\n低频：亮度变化慢，反映大块区域、整体结构、平滑色彩\n高频：亮度变化快，反映纹理、边缘、细节\n\n\n像素表示转换成频域表示：一般由二维傅立叶变换2D-FFT变换实现\n\n由振幅（幅度谱）和相位组成\n\n图像去雾任务\n\n雾霾主要降低了高频能量：图像边缘、细节模糊。但相位变化小（图像结构位置基本没变） \n​    &#x3D;&#x3D;&gt; 有大量“真实图像”的相近信息\n从频域重建：分析幅度谱，调整高低频分布，增强模糊的高频。然后将修改后的频域FFT变回空间域，得到更清晰的图像。\n\n分别输入实部和虚部（幅度谱和相位信息）\n\n图像实虚部 &#x3D;&#x3D;&gt; 学习和gt之间的残差                   超分任务\n物理意义上的电场实部虚部 &#x3D;&#x3D;&gt; loss函数约束\n\n根据稀疏观测计算\n根据发射机位置计算 Physics-Informed Neural Networks for Path Loss Estimation by Solving Electromagnetic Integral Equations\n\n作为不同（4个）channel输入\n\n","categories":["papers","work2"],"tags":["diffusion","cv","frequency"]},{"title":"全局异常处理","url":"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%BC%80%E5%8F%91/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","content":"使用HandlerExceptionResolver&#x2F;ControllerAdvice方案进行全局异常处理实例\n控制台输出：\nERROR ...ForumExceptionHandler.buildTastMsg(ForumExceptionHandler.java:xx)\n\n这里ForumExceptionHandler就是用来做全局异常处理的，是HandlerExceptionResolver接口的实现类\nHandlerExceptionResolverspring提供的一种异常处理机制，可以在应用程序中以统一的方式处理控制器引发的异常\n使用：创建一个实现接口的类，在类中定义如何处理异常（ForumExceptionHandler）\n实践中，遇到异常时会根据请求的类型（接口还是页面）返回不同的结果\n这里分为两种异常处理场景：REST接口请求异常、普通页面请求异常\n1. REST接口请求异常（前后端分离接口）就是用户调用一个接口（发出一个请求），后端返回的是JSON格式的错误信息，不是网页，用于前端处理\n\n响应：后端给前端的回信，包含\n\n状态码：比如200 - 成功，404 - 找不到，500 - 服务器出错\n响应头：格式（JSON还是HTML）、编码方式\n响应体：实际内容（JSON数据、HTML页面代码）\n\n视图对象ModelAndView：用来告诉 Spring MVC 要渲染哪个页面（视图），以及往页面里塞什么数据（模型）\n\nModel：就是要传给页面的数据（比如错误码、错误提示）\nView：就是要显示的页面模板（比如 error/404.html）\n\n在普通页面异常中需要渲染一个错误页面\n\n流程：\n\n判断响应是否已经提交：如果是就返回一个空的ModelAndView，不再处理\n如果响应没有提交，就清空之前的响应内容，设置响应类型为application&#x2F;json\n把错误信息写成JSON输出：用 response.getWriter() 把错误状态对象（比如 errStatus 里的错误码、错误提示）转成 JSON 字符串，写给前端\n返回空的ModelAndView：因为已经手动把JSON写回响应了，所以返回空的视图对象，告诉Spring MVC不需要再渲染页面\n\n2. 普通页面请求异常（直接访问网页）提供友好错误页面而不是JSON代码\n流程：\n\n获取错误页面的视图名称：根据错误状态（404&#x2F;500）找到对应的错误页面模板（error&#x2F;404.html)\n创建ModelAndView对象：视图名称为刚找到的错误页面模板\n设置响应类型为HTML\n往 ModelAndView 里塞错误信息：把**错误码、错误提示**等信息放到 ModelAndView 里，这样错误页面模板就能拿到这些数据并显示出来\n返回 ModelAndView：Spring MVC 会根据这个对象渲染出错误页面，返回给浏览器。\n\n@ControllerAdvice是springMVC提供的全局异常处理注解，可以拦截所有**@Controller 和 @RestController 抛出的异常**，并统一处理，避免在每个接口里重复写 try-catch\n注意：\n\n**@ControllerAdvice**：标记这是一个全局异常处理器，会拦截所有控制器的异常\n**@ExceptionHandler**：指定要处理的异常类型（比如 ForumException.class、RuntimeException.class）\n\n\n先定义基础类：异常美剧、自定义业务异常、统一响应对象\n\n// 异常枚举 ==&gt; 可以定义一些业务异常代码public enum StatusEnum &#123;    SUCCESS(200, &quot;操作成功&quot;),    RECORDS_NOT_EXISTS(404, &quot;记录不存在&quot;),    UNEXPECT_ERROR(500, &quot;系统异常，请稍后再试&quot;);    private final int code;    private final String msg;    StatusEnum(int code, String msg) &#123;        this.code = code;        this.msg = msg;    &#125;    public int getCode() &#123; return code; &#125;    public String getMsg() &#123; return msg; &#125;&#125;// 自定义业务异常public class ForumException extends RuntimeException &#123;    private final Status status;    public ForumException(StatusEnum statusEnum) &#123;        this.status = Status.newStatus(statusEnum, null);    &#125;    public ForumException(StatusEnum statusEnum, String detail) &#123;        this.status = Status.newStatus(statusEnum, detail);    &#125;    public Status getStatus() &#123; return status; &#125;&#125;// 统一响应对象public class Status &#123;    private int code;    private String msg;    public static Status newStatus(StatusEnum enumType, String detail) &#123;        Status status = new Status();        status.code = enumType.getCode();        status.msg = detail == null ? enumType.getMsg() : enumType.getMsg() + &quot;：&quot; + detail;        return status;    &#125;    // getter/setter    public int getCode() &#123; return code; &#125;    public void setCode(int code) &#123; this.code = code; &#125;    public String getMsg() &#123; return msg; &#125;    public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125;\n\n\n全局异常处理器：可以用@ControllerAdvice注解标记，配合@ExceptionHandler处理不同类型的异常\n\nimport org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletResponse;import java.io.IOException;// 只要在全局异常处理器类上加上这个注解，Spring就会自动扫描并把它注册为全局异常处理的Bean@ControllerAdvicepublic class GlobalExceptionHandler &#123;    // 处理 REST 接口异常（返回 JSON）    @ExceptionHandler(value = &#123;ForumException.class, RuntimeException.class&#125;)    public ModelAndView handleApiException(Exception ex, HttpServletResponse response) throws IOException &#123;        Status status = buildToastMsg(ex);        // 判断是否是 AJAX/REST 请求（可以根据请求头或 URL 前缀判断）        if (isRestRequest(response)) &#123;            // 重置响应，返回 JSON            response.reset();            response.setContentType(&quot;application/json;charset=UTF-8&quot;);            response.getWriter().write(&quot;&#123;\\&quot;code\\&quot;:&quot; + status.getCode() + &quot;,\\&quot;msg\\&quot;:\\&quot;&quot; + status.getMsg() + &quot;\\&quot;&#125;&quot;);            // 返回空的 ModelAndView，告诉 Spring MVC 不需要渲染页面            return new ModelAndView();        &#125; else &#123;            // 普通页面请求，返回错误页面            ModelAndView mv = new ModelAndView(&quot;error/error&quot;);            mv.addObject(&quot;status&quot;, status);            return mv;        &#125;    &#125;    // 异常分类处理：使用istanceof判断属于什么异常    private Status buildToastMsg(Exception ex) &#123;        if (ex instanceof ForumException) &#123;            return ((ForumException) ex).getStatus();        &#125; else &#123;            return Status.newStatus(StatusEnum.UNEXPECT_ERROR, ex.getMessage());        &#125;    &#125;    // 判断是否是 REST 接口请求（这里简化为判断请求头里是否有 Accept: application/json）    private boolean isRestRequest(HttpServletResponse response) &#123;        // 实际项目中可以根据请求头、URL 前缀（如 /api/）等判断        return response.getContentType() != null &amp;&amp; response.getContentType().contains(&quot;application/json&quot;);    &#125;&#125;\n\n使用：\n@RestControllerpublic class TestController &#123;    // 测试 REST 接口异常    @GetMapping(&quot;/api/article/&#123;id&#125;&quot;)    public String getArticle(Long id) &#123;        if (id == 999) &#123;            // 正常抛出业务异常即可，@ControllerAdvice会自动拦截处理            throw new ForumException(StatusEnum.RECORDS_NOT_EXISTS, &quot;文章ID=999不存在&quot;);        &#125;        return &quot;文章内容&quot;;    &#125;    // 测试普通页面请求异常    @GetMapping(&quot;/article/&#123;id&#125;&quot;)    public String getArticlePage(Long id) &#123;        if (id == 999) &#123;            throw new ForumException(StatusEnum.RECORDS_NOT_EXISTS, &quot;文章ID=999不存在&quot;);        &#125;        return &quot;article&quot;; // 返回页面视图    &#125;&#125;\n\n区别\nHandlerExceptionResolver：用接口处理异常，可以编写任何处理逻辑，但是和Spring MVC组件集成不够紧密，需要手动添加配置\n@ControllerAdvice：定义全局异常处理类的注解，可以使用@ExceptionHandler注解来处理不同类型的异常（需要配合使用）。这种方法更容易即成，但是逻辑可能没那么灵活\n\n可以共存，@ControllerAdvice优先级更高，也可以指定\n","categories":["基础知识","开发"],"tags":["异常处理"]},{"title":"后端是如何返回JSON/XML的","url":"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%BC%80%E5%8F%91/%E5%90%8E%E7%AB%AF%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9EJSON-XML%E7%9A%84/","content":"返回文本数据\ncontroller上添加@RestController注解：直接返回json\n如果controller注解是@Controller，可以添加@ResponseBody注解实现返回json\n通过HttpServletResponse方法将返回数据手动写入到输出流中。比如前面全局异常处理同时支持返回页面+json数据两种方式，在全局异常处理中可以进行分条件输出\n\n返回网页网页实际上也是一种文本，返回网页更准确的说法是返回渲染视图。\n接口实现：Controlleer上的注解是@Controller，没有@RestController，返回一个网页模板的相对路径（string）\n@Controller // 表示处理页面请求public class IndexController extends BaseViewController &#123;    @Autowired    private IndexRecommendHelper indexRecommendHelper;    @GetMapping(path = &#123;&quot;/&quot;, &quot;&quot;, &quot;/index&quot;, &quot;/login&quot;&#125;)  \t// 方法参数说明：    //    - Model model：用于往页面传递数据（相当于前端的变量）    //    - HttpServletRequest request：获取请求相关信息（比如请求参数）    public String index(Model model, HttpServletRequest request) &#123;        String activeTab = request.getParameter(&quot;category&quot;); // 从请求参数中获取 &quot;category&quot; 参数值      \t//调用助手类的方法，根据激活标签页构建首页所需的所有数据（文章列表、分类、推荐内容等）        //    IndexVo 是一个数据封装类，里面包含首页展示需要的所有字段        IndexVo vo = indexRecommendHelper.buildIndexVo(activeTab);      \t//将封装好的首页数据存入Model，页面可以通过 &quot;vo&quot; 这个变量获取数据        //    比如页面中可以用 $&#123;vo.articleList&#125; 拿到文章列表        model.addAttribute(&quot;vo&quot;, vo);        return &quot;views/home/index&quot;; // Spring MVC会渲染这个页面并返回给浏览器    &#125;&#125;\n\n返回XML可以实现一个rest服务\n@RestController@RequestMapping(path = &quot;xml&quot;)public class XmlParamsRest &#123;    @PostMapping(path = &quot;show&quot;, consumes = &#123;MediaType.APPLICATION_XML_VALUE&#125;,            produces = MediaType.APPLICATION_XML_VALUE)    public XmlRes show(@RequestBody XmlBean bean) &#123;        System.out.println(bean);        XmlRes res = new XmlRes();        res.setCode(0);        res.setMsg(&quot;success&quot;);        res.setData(bean.toString());        return res;    &#125;&#125;\n\n\n@RestController：返回的不是视图\n@PostMapping注解中的 consumes 和 produces参数，指定了”application&#x2F;xml”，表示接收和返回的都是xml文档\n@RequestBody是用来告诉 Spring MVC：把整个 HTTP 请求体（Body）的内容，转换成你指定的 Java 对象（这里是 XmlBean）。XML 参数是放在请求体里的，如果不加这个注解，Spring MVC 根本不会去解析请求体里的 XML 内容，自然就无法给 XmlBean 赋值 &#x3D;&#x3D;&gt; 这里是接收参数\n\n\n@RestController：管出，也就是返回响应\n@RequestBody：管进，也就是接受参数\n","categories":["基础知识","开发"],"tags":["返回","前后端交互","JSON","XML"]},{"title":"优雅编程之Lombok","url":"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%BC%80%E5%8F%91/%E4%BC%98%E9%9B%85%E7%BC%96%E7%A8%8B%E4%B9%8BLombok/","content":"Lombok可以通过注解的形式简化java代码\n比如：通过@Getter、@Setter注解，在**编译**（不在源码中）时自动为javabean属性生成getter、setter方法，还可以生成构造方法、equals方法、hashCode方法、toString方法\n集成Springboot2.1x版本后不需要显示添加lombok依赖了，新版的intellijIDEA也内置了lombok插件，不用安装\n常用注解@Getter &#x2F; @Setterclass CmowerLombok &#123;  @Getter @Setter private int age;  @Getter private String name;  @Setter private BigDecimal money;&#125;@Getter @Setterclass CmowerLombok &#123;  private int age;  private String name;  private BigDecimal money;&#125;\n\n@ToString可以方便的打印日志\n@ToStringclass CmowerLombok &#123;  private int age;  private String name;  private BigDecimal money;    /*  \t反编译内容为：\t\tpublic String toString() &#123;\t\treturn &quot;CmowerLombok(age=&quot; + this.age + &quot;, name=&quot; + this.name + &quot;, money=&quot; + this.money + &quot;)&quot;;\t\t&#125;  */&#125;\n\n@Data此注解可以生成getter/setter、equals、hashCode、toString，总和选项\n@Dataclass CmowerLombok &#123;\tprivate int age;  private String name;  private BigDecimal money;&#125;\n\n/** * 作用：判断另一个对象是否是当前类（或其子类）的实例，避免父类与子类之间的 equals 逻辑混乱 */protected boolean canEqual(Object other) &#123;    // 判断传入的对象是否是 CmowerLombok 类的实例    return other instanceof CmowerLombok;&#125;/** * hashCode 方法用于生成对象的哈希码 * 在 HashMap、HashSet 等集合中，哈希码用于快速定位对象 */public int hashCode() &#123;    // 这里的 PRIME 变量名是 Lombok 生成时的占位符，实际值为 59（代码中直接用 59 计算）    int PRIME = true;    // 哈希码初始值为 1    int result = 1;    // 基于 age 属性计算哈希码：每次乘以质数 59，再加上属性的哈希值    // 质数可以减少哈希冲突的概率    int result = result * 59 + this.getAge();    // 处理 name 属性：如果为 null，用 43 作为默认哈希值；否则用 name 的哈希值    Object $name = this.getName();    result = result * 59 + ($name == null ? 43 : $name.hashCode());    // 处理 money 属性：同样的逻辑，null 时用 43    Object $money = this.getMoney();    result = result * 59 + ($money == null ? 43 : $money.hashCode());    // 返回最终计算的哈希码    return result;&#125;\n\n@Slf4j自动生成日志对象，可以根据自己的日志方式选择不同的注解\nSlf4j适配多种实现\nimport lombok.extern.slf4j.Slf4j;@Slf4jpublic class Log4jDemo &#123;    public static void main(String[] args) &#123;      \t// 直接用 log 对象即可        log.info(&quot;level:&#123;&#125;&quot;, &quot;info&quot;);        log.warn(&quot;level:&#123;&#125;&quot;, &quot;warn&quot;);        log.error(&quot;level:&#123;&#125;&quot;, &quot;error&quot;);    &#125;&#125;  /*  \t 手动创建日志对象    private static final Logger log = LoggerFactory.getLogger(Log4jDemo.class);  */ \n\n@Builder使用建造者方式来创建对象，然后就可以通过**链式调用的方式来对对象赋值**了\n@Builder@ToStringpublic class BuilderDemo &#123;    private Long id;    private String name;    private Integer age;    public static void main(String[] args) &#123;        BuilderDemo demo = BuilderDemo.builder().age(18).name(&quot;沉默王二&quot;).build();        System.out.println(demo);    &#125;&#125;\n\n处理流程\njavac 对源代码进行分析，生成一棵抽象语法树（AST）\njavac 编译过程中调用实现了 JSR 269 的 Lombok 程序\nLombok 对 AST 进行处理，找到 Lombok 注解所在类对应的语法树（AST），然后修改该语法树，增加 Lombok 注解定义的相应树节点\njavac 使用修改后的抽象语法树生成字节码文件\n\n","categories":["基础知识","开发"],"tags":["Lombok","优雅编程"]},{"title":"WEB三大组件之Listener","url":"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%BC%80%E5%8F%91/WEB%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BListener/","content":"基本定义Listener是web中的事件监听器，能监听web应用中特定事件的发生，并在事件触发时自动执行预设的逻辑，并且不侵入业务代码\n比如：\n\n应用启动的的时候加载全局配置、初始化缓存\n用户第一次访问的时候初始化session\n请求结束的时候记录访问日志\n\n特点：\n\n不会主动执行，只有当对应事件发生时才会被容器调用\n可以监听整个应用、用户会话或单个请求的生命周期，适合做全局监控和初始化\n\n常见的Listener类型Java Web 规范定义了多种标准监听器，按监听对象可分为四类：\n\n\n\n类型\n作用\n典型场景\n\n\n\nServletContextListener\n监听 ServletContext（应用全局上下文）的创建与销毁\n应用启动时加载配置、初始化连接池；应用关闭时释放资源\n\n\nHttpSessionListener\n监听 HttpSession（用户会话）的创建与销毁\n**统计在线用户数**；用户登录 &#x2F; 退出时更新状态\n\n\nServletRequestListener\n监听 ServletRequest（请求）的创建与销毁\n**记录请求耗时**；统一处理请求日志\n\n\nAttributeListener\n监听 ServletContext&#x2F;Session&#x2F;Request 中属性的增删改\n监控全局属性变化；实现属性缓存刷新\n\n\n使用使用@WebListener标记是一个web监听器\n// 1. 定义监听器类@WebListener // 标记这是一个 Web 监听器public class OnlineCountListener implements HttpSessionListener &#123;    // 在线人数计数器    private int onlineCount = 0;    // 2. 监听 Session 创建事件（用户第一次访问时触发）    @Override    public void sessionCreated(HttpSessionEvent se) &#123;        onlineCount++;        // 把在线人数存入全局上下文，供页面显示        se.getSession().getServletContext().setAttribute(&quot;onlineCount&quot;, onlineCount);        System.out.println(&quot;用户上线，当前在线人数：&quot; + onlineCount);    &#125;    // 3. 监听 Session 销毁事件（用户退出/超时后触发）    @Override    public void sessionDestroyed(HttpSessionEvent se) &#123;        onlineCount--;        se.getSession().getServletContext().setAttribute(&quot;onlineCount&quot;, onlineCount);        System.out.println(&quot;用户下线，当前在线人数：&quot; + onlineCount);    &#125;&#125;\n\n如果使用了@WebListener注解，要在springboot启动类上添加 @ServletComponentScan，让 Spring 自动扫描并注册监听器\n@SpringBootApplication@ServletComponentScan // 扫描 @WebListener、@WebServlet、@WebFilterpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;\n\n如果监听器类没有注解，可以用ServletListenerRegistrationBean手动注册\n@Beanpublic ServletListenerRegistrationBean&lt;OnlineCountListener&gt; onlineCountListener() &#123;    ServletListenerRegistrationBean&lt;OnlineCountListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;();    registrationBean.setListener(new OnlineCountListener());    return registrationBean;&#125;\n\n","categories":["基础知识","开发"],"tags":["web组件"]},{"title":"WEB三大组件之Filter","url":"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%BC%80%E5%8F%91/WEB%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BFilter/","content":"基本定义Filter，过滤器，属于Servlet规范，并不是Spring独有的\n作用：拦截http请求，做一些业务逻辑操作\n一个http请求过来之后，一个Filter的工作流程：\n\n首先**进入filter，执行相关业务逻辑**\n**若判定通行，则进入Servlet逻辑，Servlet执行完毕之后，又返回Filter**，最后在返回给请求方\n判定失败，直接返回，不需要将请求发给Servlet\n\n所以可以用filter来实现用户身份识别（获取、校验），然后将识别的用户信息保存到TreadLocal对应的上下文中，这样在后续的请求链路中任何地方都可以直接获取当前登录用户\n使用实现Filter接口即可\neg：输出请求日志的拦截器\n@Slf4j@WebFilterpublic class ReqFilter implements Filter &#123;    public ReqFilter() &#123;        System.out.println(&quot;init reqFilter&quot;);    &#125;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)            throws IOException, ServletException &#123;        HttpServletRequest req = (HttpServletRequest) request;        log.info(&quot;url=&#123;&#125;, params=&#123;&#125;&quot;, req.getRequestURI(), JSON.toJSONString(req.getParameterMap()));        chain.doFilter(req, response);    &#125;    @Override    public void destroy() &#123;    &#125;&#125;\n\n\n在doFilter方法中添加业务逻辑\n\n如果允许访问继续，则执行chain.doFilter(req, response);，如果不执行上面这一句，则访问到此为止\n\n\n注册WebFilter注解将@WebFilter标注到自己实现的过滤器上（上述例子中的ReqFilter），其中参数配置：\n\n\n\n参数名\n类型\n核心作用\n是否必填\n\n\n\nfilterName\nString\n过滤器名称，用于在多过滤器时区分不同FIlter，或者配合@WebFilter排序\n否\n\n\nvalue&#x2F;urlPatterns\nString[]\n【最常用】指定过滤器拦截的 URL 路径（拦截所有&#x2F;某路径下&#x2F;以xx为后缀&#x2F;精准拦截）\n是（二选一）\n\n\nservletNames\nString[]\n精准拦截指定名称的Servlet处理的请求，不是所有url\n否\n\n\ndispatcherTypes\nDispatcherType[]\n指定拦截的请求类型（如请求、转发、包含等）\n否（默认 REQUEST）\n\n\nasyncSupported\nboolean\n是否支持异步请求（如果拦截的servlet是用来异步处理，那Filter也必须开启）\n否（默认 false）\n\n\ninitParams\nWebInitParam[]\n过滤器初始化参数\n否\n\n\ndescription\nString\n过滤器描述信息（纯注释性参数）\n否\n\n\ndisplayName\nString\n过滤器展示名称（纯注释性参数）\n否\n\n\n🌟 使用这个注解的时候需要在启动&#x2F;配置类上添加@ServletComponentScan注解来启用\nFilterRegistrationBean@WebFilter指定filter优先级比较麻烦，不如FilterRegistrationBean简单\n@Beanpublic FilterRegistrationBean&lt;Filter&gt; orderFilter() &#123;    FilterRegistrationBean&lt;Filter&gt; filter = new FilterRegistrationBean&lt;&gt;();    filter.setName(&quot;reqRecordFilter&quot;);    filter.setUrlPatterns(Arrays.asList(&quot;/*&quot;));    filter.setFilter(new ReqRecordFilter());    // 指定优先级    filter.setOrder(-1);    return filter;&#125;\n\n实例：实现请求日志记录实现功能：将所有外部访问都记录在日志文件中\n\n基于日志文件就可以实现整个项目的监控\n出现问题的时候可以基于此进行流量重放\n\n而过滤器Filter可以拦截web请求，其doFilter方法可以划分为三块：\n\ndoBefore：表示将请求转发到 Controller 执行之前\n记录开始执行时间\n记录请求相关信息\n\n\ndoFilter：即将请求转发到 Controller 去执行\ndoAfter：**Controller 方法执行完**\n记录结束时间，计算执行耗时\n日志输出\n\n\n\n使用Filter做日志记录的优点是适用性强，实现简单，缺点是只能记录 Controller 的请求相关信息，如果我们想统计某个 Service 方法、Mapper 方法，那么这种方式则不太合适\n&#x3D;&#x3D;&gt; 还可以用AOP的方法，但这就要自己定义切点什么的了\n核心逻辑还是「请求前处理 → 放行请求 → 请求后处理」\n1. 基础配置@Slf4j // Lombok：自动生成日志对象// 拦截所有请求；过滤器名称reqRecordFilter；支持异步请求（asyncSupported = true）@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;reqRecordFilter&quot;, asyncSupported = true）)public class ReqRecordFilter implements Filter &#123;    // 专门记录请求日志的Logger（和普通log区分开，通常会配置成输出到专门的日志文件，方便分析请求）    private static Logger REQ_LOG = LoggerFactory.getLogger(&quot;req&quot;);    // 响应头中返回traceId的key，前端可拿到这个id排查问题    private static final String GLOBAL_TRACE_ID_HEADER = &quot;g-trace-id&quot;;    // 注入项目的全局初始化服务、统计服务    @Autowired    private GlobalInitService globalInitService;    @Autowired    private StatisticsSettingService statisticsSettingService;&#125;\n\n2. 核心方法 doFilter（请求处理的主流程）\n请求前处理阶段\n\n@Overridepublic void doFilter(...) throws IOException, ServletException &#123;    long start = System.currentTimeMillis(); // 记录请求开始时间    HttpServletRequest request = null;    StopWatch stopWatch = new StopWatch(&quot;请求耗时&quot;); // 细粒度计时工具    try &#123;        // 1. 初始化请求上下文（traceId、用户IP、设备ID、登录信息等）        stopWatch.start(&quot;请求参数构建&quot;);        request = this.initReqInfo((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);        stopWatch.stop();        // 2. 处理跨域（CORS）        stopWatch.start(&quot;cors&quot;);        CrossUtil.buildCors(request, (HttpServletResponse) servletResponse);        stopWatch.stop();        // 3. 放行请求：调用Controller/Service处理业务（核心！）        stopWatch.start(&quot;业务执行&quot;);        filterChain.doFilter(request, servletResponse);    &#125; \n\ninitReqInfo()：核心初始化方法\nCrossUtil.buildCors()：处理跨域（比如前端访问后端接口时的跨域问题，过滤器统一处理）\nfilterChain.doFilter()：放行请求 → 这行代码执行后，才会走到 Controller 的接口方法\n\n请求后处理阶段finally块，无论是否异常都会执行\n\n    finally &#123;        // 防止业务执行异常导致stopWatch没停止，先强制停止        if (stopWatch.isRunning()) &#123;            stopWatch.stop();        &#125;        // 1. 输出请求日志（URL、IP、耗时、用户ID等）        stopWatch.start(&quot;输出请求日志&quot;);        buildRequestLog(ReqInfoContext.getReqInfo(), request, System.currentTimeMillis() - start);        stopWatch.stop();        // 2. 清空上下文：避免线程复用导致数据污染（MDC/ReqInfoContext是线程级别的）        MdcUtil.clear(); // 清空链路追踪的traceId        ReqInfoContext.clear(); // 清空请求上下文        // 3. 非生产环境打印细粒度耗时（方便开发调试）        if (!isStaticURI(request) &amp;&amp; !EnvUtil.isPro()) &#123;            log.info(&quot;&#123;&#125; - cost:\\n&#123;&#125;&quot;, request.getRequestURI(), stopWatch.prettyPrint(TimeUnit.MILLISECONDS));        &#125;    &#125;&#125;\n\nbuildRequestLog()：核心日志构建方法\nstopWatch.prettyPrint()：打印每个步骤的耗时（比如开发环境能看到 “请求参数构建用了 3ms，业务执行用了 50ms”）\nisStaticURI()：判断是否是静态资源（css&#x2F;js&#x2F;png 等） &#x3D;&#x3D;&gt; 这里pc前台的网页也集成在项目中，所以需要排掉静态资源\n3. 辅助方法拆解\ninitReqInfo()：请求上下文初始化\n\n&#x3D;&#x3D;&gt; 给每个请求初始化「链路追踪 ID、用户信息、设备 ID、请求基本信息」，并存入ReqInfoContext（线程上下文），后续业务代码可直接获取这些信息\nprivate HttpServletRequest initReqInfo(HttpServletRequest request, HttpServletResponse response) &#123;    // 静态资源直接放行，不初始化（提升性能）    if (isStaticURI(request)) &#123;        return request;    &#125;    StopWatch stopWatch = new StopWatch(&quot;请求参数构建&quot;);    try &#123;        // 步骤1：添加全链路traceId（日志追踪用，比如一个请求的所有日志都带同一个traceId）        stopWatch.start(&quot;traceId&quot;);        MdcUtil.addTraceId(); // 生成UUID作为traceId，存入MDC        stopWatch.stop();        // 步骤2：初始化Session，用于统计在线人数（配合OnlineUserCountListener）        request.getSession().setAttribute(&quot;latestVisit&quot;, System.currentTimeMillis());        // 步骤3：构建请求基本信息（Host、Path、Referer、IP、UserAgent等）        stopWatch.start(&quot;请求基本信息&quot;);        ReqInfoContext.ReqInfo reqInfo = new ReqInfoContext.ReqInfo();        // 处理请求的Host（兼容nginx转发的X-Forwarded-Host头）        String forwardedHost = request.getHeader(&quot;X-Forwarded-Host&quot;);        String hostHeader = request.getHeader(&quot;host&quot;);        if (StringUtils.isNotBlank(forwardedHost)) &#123;            reqInfo.setHost(forwardedHost);        &#125; else if (StringUtils.isNotBlank(hostHeader)) &#123;            reqInfo.setHost(hostHeader);        &#125; else &#123;            URL reqUrl = new URL(request.getRequestURL().toString());            reqInfo.setHost(reqUrl.getHost());        &#125;        // 处理请求路径、来源页、客户端IP、浏览器UA、设备ID        reqInfo.setPath(request.getPathInfo());        reqInfo.setReferer(request.getHeader(&quot;referer&quot;)); // 从哪个页面跳过来的        reqInfo.setClientIp(IpUtil.getClientIp(request)); // 获取真实客户端IP（兼容代理）        reqInfo.setUserAgent(request.getHeader(&quot;User-Agent&quot;)); // 浏览器/设备信息        reqInfo.setDeviceId(getOrInitDeviceId(request, response)); // 设备唯一ID（统计UV用）        stopWatch.stop();        // 步骤4：包装POST请求，读取请求体（JSON参数）        request = this.wrapperRequest(request, reqInfo);        // 步骤5：初始化登录用户信息（判断用户是否登录，存入上下文）        stopWatch.start(&quot;登录用户信息&quot;);        globalInitService.initLoginUser(reqInfo); // 从Session/Token中获取用户ID等信息        stopWatch.stop();        // 步骤6：把请求信息存入线程上下文（后续业务代码可直接获取）        ReqInfoContext.addReqInfo(reqInfo);        // 步骤7：异步统计PV/UV（不阻塞请求，提升性能）        stopWatch.start(&quot;pv/uv站点统计&quot;);        AsyncUtil.execute(() -&gt; SpringUtil.getBean(SitemapServiceImpl.class).saveVisitInfo(reqInfo.getClientIp(), reqInfo.getPath()));        stopWatch.stop();        // 步骤8：响应头返回traceId（前端可拿到这个ID，排查问题时和后端日志对应）        stopWatch.start(&quot;回写traceId&quot;);        response.setHeader(GLOBAL_TRACE_ID_HEADER, Optional.ofNullable(MdcUtil.getTraceId()).orElse(&quot;&quot;));        stopWatch.stop();    &#125; catch (Exception e) &#123;        log.error(&quot;init reqInfo error!&quot;, e);    &#125; finally &#123;        // 开发环境打印参数构建的细粒度耗时        if (!EnvUtil.isPro()) &#123;            log.info(&quot;&#123;&#125; -&gt; 请求构建耗时: \\n&#123;&#125;&quot;, request.getRequestURI(), stopWatch.prettyPrint(TimeUnit.MILLISECONDS));        &#125;    &#125;    return request;&#125;\n\ngetOrInitDeviceId()：生成 &#x2F; 获取设备唯一 ID（Cookie 存储），用于统计 UV（独立访客）\nwrapperRequest()：包装 POST 请求，读取请求体（JSON 参数）并存入 reqInfo，方便日志记录\nAsyncUtil.execute()：异步执行 PV&#x2F;UV 统计，避免统计操作阻塞请求响应\n\nbuildRequestLog()：构建并输出请求日志\n\n&#x3D;&#x3D;&gt; 把请求的核心信息（方法、IP、用户 ID、URL、参数、耗时）拼接成日志，输出到REQ_LOG\nprivate void buildRequestLog(ReqInfoContext.ReqInfo req, HttpServletRequest request, long costTime) &#123;    // 静态资源/无请求信息，不记录日志    if (req == null || isStaticURI(request)) &#123;        return;    &#125;    StringBuilder msg = new StringBuilder();    // 拼接请求方法（GET/POST）    msg.append(&quot;method=&quot;).append(request.getMethod()).append(&quot;; &quot;);    // 拼接来源页（Referer）    if (StringUtils.isNotBlank(req.getReferer())) &#123;        msg.append(&quot;referer=&quot;).append(URLDecoder.decode(req.getReferer())).append(&quot;; &quot;);    &#125;    // 拼接客户端IP、浏览器UA    msg.append(&quot;remoteIp=&quot;).append(req.getClientIp());    msg.append(&quot;; agent=&quot;).append(req.getUserAgent());    // 拼接登录用户ID（已登录才显示）    if (req.getUserId() != null) &#123;        msg.append(&quot;; user=&quot;).append(req.getUserId());    &#125;    // 拼接请求URI+参数    msg.append(&quot;; uri=&quot;).append(request.getRequestURI());    if (StringUtils.isNotBlank(request.getQueryString())) &#123;        msg.append(&#x27;?&#x27;).append(URLDecoder.decode(request.getQueryString()));    &#125;    // 拼接POST请求体（JSON参数）    msg.append(&quot;; payload=&quot;).append(req.getPayload());    // 拼接总耗时    msg.append(&quot;; cost=&quot;).append(costTime);    // 输出到专门的请求日志    REQ_LOG.info(&quot;&#123;&#125;&quot;, msg);    // 保存请求计数（统计总请求数）    statisticsSettingService.saveRequestCount(req.getClientIp());&#125;\n\n传入的时候也是传入request &#x3D;&#x3D;&gt; 直接从request里面取日志信息\n\n也就是上面还包含了很多Filter做的，但是和日志无关的功能\n\n\n扫盲：\nReqInfoContext：线程级别的上下文，用ThreadLocal实现，存当前请求的所有信息，后续Service&#x2F;DAO层可直接获取（比如获取当前登录用户 ID）\nMDC：日志链路追踪工具，给每个请求加唯一traceId，所有日志都带这个ID，排查问题时能快速定位一个请求的所有日志\nStopWatch：细粒度计时，方便开发 &#x2F; 测试环境分析请求耗时瓶颈（比如 “业务执行用了100ms，参数构建用了5ms”）\n异步执行：PV&#x2F;UV统计用AsyncUtil异步执行，避免统计操作拖慢请求响应\n\n\n上下文：当前代码执行时的所有环境信息的集合1. 请求上下文：当前HTTP请求的所有信息的集合\n包含请求 URL、客户端 IP、登录用户 ID、设备 ID、请求参数、traceId等等\n\n&#x3D;&#x3D;&gt; 让整个请求链路（Filter → Controller → Service → DAO）都能直接获取这些信息，不用在每个方法里都传参\n比如上述代码中的 ReqInfoContext，就是把当前请求的所有信息存在一个对象里，后续 Service 层想获取 “当前登录用户 ID”，直接 ReqInfoContext.getReqInfo().getUserId() 就能拿到，**不用在每个 Service 方法里都加个 userId 参数**\n2. 线程上下文：因为web服务器是多线程的（每个请求都有一个线程），所以请求上下文必须是线程隔离的\n用ThreadLocal存储，每个线程有自己独立的上下文，不会互相干扰\n\n典型例子：\n\nReqInfoContext：用 ThreadLocal 存当前**请求**的信息\nMdcUtil：用 ThreadLocal 存当前请求的**traceId**，保证每个线程的日志都带自己的 traceId\n\n🌟上下文销毁：请求结束后，在 finally 块里调用 ReqInfoContext.clear()，清空当前线程的上下文，避免线程池复用导致数据污染\n","categories":["基础知识","开发"],"tags":["web组件"]},{"title":"WEB三大组件之servlet","url":"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%BC%80%E5%8F%91/WEB%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservlet/","content":"基本定义Servlet 是Java EE规范中定义的请求处理基础组件，核心作用只有一个：\n接收前端 HTTP 请求（如 GET&#x2F;POST），调用后端业务逻辑，再把处理结果返回给前端。\n它是前端和后端业务逻辑之间的 “中转站”，是 Web 项目的 “入口层”。\n\n\nServlet（LoginServlet）：只做 “请求接收” 和 “响应返回”，不关心 “怎么校验密码”；\n\n业务逻辑（UserService）：只做 “密码加密校验、用户状态判断”，不关心 “请求从哪来、响应怎么回”；\n\n\n两者分工明确：Servlet 管 “和前端交互”，业务逻辑管 “实现具体功能”。\n\n使用一般是继承HttpServlet，然后覆盖doGet、doPost等方法\n识别1. @WebServlet在自定义的servlet类上添加@WebServlet\n// 注解指定这个 Servlet 处理的 URL 路径@WebServlet(urlPatterns = &quot;/annotation&quot;)public class AnnotationServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        String name = req.getParameter(&quot;name&quot;);        PrintWriter writer = resp.getWriter();        writer.write(&quot;[AnnotationServlet] welcome &quot; + name);        writer.flush();        writer.close();    &#125;&#125;\n\nurlPatterns = &quot;/annotation&quot;：表示当用户访问 http://localhost:8080/annotation 时，这个 Servlet 会处理请求  &#x3D;&#x3D;&gt;  这一步相当于告诉容器：“这个类是 Servlet，负责 /annotation 路径的请求”\n然后在springboot启动类上添加@SpringBootApplication\n@SpringBootApplication// 扫描当前包及其子包下的 @WebServlet、@WebFilter、@WebListener 注解@ServletComponentScanpublic class PaicodingApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(PaicodingApplication.class, args);    &#125;&#125;\n\nSpring Boot 默认不会扫描 @WebServlet 注解，必须加这个注解，Spring 才会去扫描并把你的 AnnotationServlet 注册到容器里 &#x3D;&#x3D;&gt; 相当于告诉 Spring：“帮我把所有带 @WebServlet 的类都注册成 Servlet”\n2. ServletRegistrationBean当你的 Servlet 类没有任何注解（比如 @WebServlet）时，Spring Boot 无法自动扫描到它，这时就需要用 ServletRegistrationBean 手动把它注册到容器里\n先定义无注解的Servlet类\npublic class RegisterBeanServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        String name = req.getParameter(&quot;name&quot;);        PrintWriter writer = resp.getWriter();        writer.write(&quot;[RegisterBeanServlet] welcome &quot; + name);        writer.flush();        writer.close();    &#125;&#125;\n\n然后用ServletRegistrationBean注册servlet\n@Beanpublic ServletRegistrationBean servletBean() &#123;    // 1. 创建 Servlet 注册对象    ServletRegistrationBean registrationBean = new ServletRegistrationBean();    // 2. 配置该 Servlet 处理的 URL 路径    registrationBean.addUrlMappings(&quot;/register&quot;);     // 3. 绑定要注册的 Servlet 实例    registrationBean.setServlet(new RegisterBeanServlet());    // 4. 返回注册对象，Spring 会自动完成注册    return registrationBean;&#125;\n\n","categories":["基础知识","开发"],"tags":["web组件"]},{"title":"MapStruct","url":"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%BC%80%E5%8F%91/MapStruct/","content":"基本定义在xxxStructMapper接口中定义好方法后，MapStruct【映射器】可以在**编译**的时候生成相应的实现类\n&#x3D;&#x3D;&gt; 主要针对DO对象转换成DTO对象\n如果没有MapStruct：\npublic static ArticleDTO toDto(ArticleDO articleDO) &#123;    if (articleDO == null) &#123;        return null;    &#125;    ArticleDTO articleDTO = new ArticleDTO();    articleDTO.setAuthor(articleDO.getUserId());    articleDTO.setArticleId(articleDO.getId());    articleDTO.setArticleType(articleDO.getArticleType());\t\t...    // 设置类目id    articleDTO.setCategory(new CategoryDTO(articleDO.getCategoryId(), null));    return articleDTO;&#125;\n\n使用MapStruct可以：\n// MapStruct的核心注解，标记这个接口为一个映射器，让MapStruct注解处理器编译时为此接口生成实现@Mapperpublic interface ArticleStructMapper &#123;  // Mappers.getMapper是MapStruct提供的工具方法，可以在不使用spring和其他依赖注入框架情况下获取映射器的实例（静态实例）  ArticleStructMapper INSTANCE = Mappers.getMapper 是(ArticleStructMapper.class);  ArticleDTO toDTO(ArticleDO do);&#125;\n\n这里定义了一个接口ArticleStructMapper，将DO对象 ArticleDO转换成DTO对象 ArticleDTO\n用法\n在pom.xml文件中添加\n定义映射器接口：使用 @Mapping 做转换\n\n// 一个比较复杂的实现@Mapperpublic interface ColumnStructMapper &#123;    ColumnStructMapper INSTANCE = Mappers.getMapper(ColumnStructMapper.class);    /**     * ColumnInfoDO to ColumnDTO     * @param columnInfoDO     * @return     */    // 一些名称转换：sources 是参数（源）, target 是目标    @Mapping(source = &quot;id&quot;, target = &quot;columnId&quot;)    @Mapping(source = &quot;columnName&quot;, target = &quot;column&quot;)    @Mapping(source = &quot;userId&quot;, target = &quot;author&quot;)    // 一些类型转换：Date 转 Long（Date对象转换为时间戳）  \t\t// - 用expression做更复杂的转换    @Mapping(target = &quot;publishTime&quot;, expression = &quot;java(columnInfoDO.getPublishTime().getTime())&quot;)    @Mapping(target = &quot;freeStartTime&quot;, expression = &quot;java(columnInfoDO.getFreeStartTime().getTime())&quot;)    @Mapping(target = &quot;freeEndTime&quot;, expression = &quot;java(columnInfoDO.getFreeEndTime().getTime())&quot;)    ColumnDTO infotoDto(ColumnInfoDO columnInfoDO);\t\t\t// - infotoDtos转换对象列表    List&lt;ColumnDTO&gt; infotoDtos(List&lt;ColumnInfoDO&gt; columnInfoDOs);    @Mapping(source = &quot;column&quot;, target = &quot;columnName&quot;)    @Mapping(source = &quot;author&quot;, target = &quot;userId&quot;)    // Long 转 Date    @Mapping(target = &quot;freeStartTime&quot;, expression = &quot;java(new java.util.Date(req.getFreeStartTime()))&quot;)    @Mapping(target = &quot;freeEndTime&quot;, expression = &quot;java(new java.util.Date(req.getFreeEndTime()))&quot;)    ColumnInfoDO toDo(ColumnReq req);&#125;\n\n","categories":["基础知识","开发"],"tags":["优雅编程"]},{"title":"事务及使用实例","url":"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%BC%80%E5%8F%91/%E4%BA%8B%E5%8A%A1%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B/","content":"ACID特性\n原子性 Atomicity：事务包含的所有操作要么全部成功，要么全部失败回滚\n一致性 Consistency：事务执行前后数据库的状态保持一致，比如库存、金额总额一致\n隔离型 Isolation：多个用户并发访问数据库时，事务直接不会互相干扰\n持久性 Durability：事务一旦提交，数据库中数据改变是持久的，即使数据库故障也不会丢失事务操作\n\n数据库事务的实现原理MySQL的InnoDB引擎：\n\n使用redo log（重做日志）保证持久性\n使用undo log（回滚日志）保证原子性\n使用锁机制、MVCC保证隔离性\n\n&#x3D;&#x3D;&gt; 隔离级别：repeatable read 可重复读\n数据库事务的隔离级别\n读未提交 read uncommitted：别人改了一半也能看到 &#x3D;&#x3D;&gt; 脏读\n读已提交 read committed：读已经发布的内容 &#x3D;&#x3D;&gt; 不可重复读（不可用于要求数据一致性场景 行锁）\n可重复读 repeatable read（SQL默认）：读到任务开始时读快照 &#x3D;&#x3D;&gt; 幻读（间隙锁）\n串行化 serializable：独占锁，其余事务不可读不可写，排队等待当前食物结束（表锁，避免所有并发问题，性能差）\n\nredis事务将多个命令请求打包，顺序执行打包的命令，并且不被打断\nMULTI --&gt; (放指令) ... --&gt; EXEC(开始执行)\n\n\n不支持原子性：redis事务不支持回滚，也就是事务中的指令如果没有出错的话是会正常执行掉的\n\n不支持持久性：redis的持久化方式为：快照RDB+AOF。其中AOF比RDB的实时性更好，有三种模式\n\nalways：每次有数据修改都同步AOF\n\neverysec：每秒同步一次\n\nno：让操作系统决定多长时间同步一次（一般为30秒）\n这里everysec、no都存在数据丢失的情况，所以不支持持久性\n\n\n\n\n解决redis事务的缺陷方法：使用Lua脚本 &#x3D;&#x3D;&gt; 它是原子操作，也就是批量执行多条redis命令，一段Lua脚本执行时不会有其余脚本&#x2F;redis命令同时执行。但是Lua脚本也不能回滚（原子操作 !&#x3D; 原子性）\n使用声明式事务：使用@Transactional/** * 保存文章，当articleId存在时，表示更新记录；不存在时，表示插入 */// 指定所有异常（包括运行时异常和检查型异常）都会触发回滚@Transactional(rollbackFor = Exception.class)@Overridepublic Long saveArticle(ArticlePostReq req, Long author) &#123;    ArticleDO article = ArticleConverter.toArticleDo(req, author);    String content = imageService.mdImgReplace(req.getContent());    if (NumUtil.nullOrZero(req.getArticleId())) &#123;        return insertArticle(article, content, req.getTagIds());    &#125; else &#123;        return updateArticle(article, content, req.getTagIds());    &#125;&#125;\n\n1. 修饰位置\n方法上添加注解\n类上添加注解：类中所有**公共方法**都支持事务\n\n2. 参数\n\n\n属性名\n类型\n核心作用\n默认值\n常用场景\n\n\n\nvalue&#x2F;transactionManager\nString\n指定事务管理器\n容器默认的事务管理器\n多数据源 &#x2F; 多事务管理器场景\n\n\npropagation\nPropagation\n事务传播行为 &#x3D;&#x3D;&gt;  当一个有事务的方法调用另一个方法时，事务该如何传递\nREQUIRED\n嵌套调用时控制事务创建规则\n\n\nisolation\nIsolation\n事务隔离级别\nDEFAULT（数据库默认）\n解决脏读 &#x2F; 不可重复读 &#x2F; 幻读\n\n\ntimeout\nint\n事务超时时间（秒）\n-1（永不超时）\n防止长事务占用资源\n\n\nreadOnly\nboolean\n是否只读事务\nfalse\n纯查询操作，优化性能\n\n\nrollbackFor\nClass&lt;? extends Throwable&gt;[]\n指定触发回滚的异常类型\n仅运行时异常（RuntimeException）\n需要捕获检查型异常并回滚\n\n\nrollbackForClassName\nString[]\n同上（异常类名）\n-\n不想引入异常类时使用\n\n\nnoRollbackFor\nClass&lt;? extends Throwable&gt;[]\n指定不回滚的异常类型\n-\n特定异常不希望回滚\n\n\nnoRollbackForClassName\nString[]\n同上（异常类名）\n-\n-\n\n\n🌟注意rollbackFor：不指定具体异常时，默认只有**运行时异常**才会触发事务回滚\n\n\n运行时异常：代码逻辑问题，不需要try-catch显示捕获\n\n检查型异常：外部资源异常（IO、网络、数据库连接），需要try-catch显示捕获或声明抛出throws\n\n\n\n编程式事务声明式事务的约束：最小粒度为方法级别，如果想在**方法内部分代码块**进行事务约束，可用编程式事务\n&#x3D;&#x3D;&gt; 比如要下载图片并上传这种耗时操作不需要加入事务\n🌟 使用事务时牢记：最小范围使用原则\n1. 注入 TransactionTemplate@Autowiredprivate TransactionTemplate transactionTemplate;\n\n\nTransactionTemplate 是Spring提供的编程式事务工具类，封装了事务的开启、提交、回滚等操作\n\n它会自动使用 Spring 容器中的事务管理器，无需手动配置\n\n\n2. 用 transactionTemplate.execute() 包裹业务逻辑// 2. 将逻辑改造为编程式事务@Overridepublic Long saveArticle(ArticlePostReq req, Long author) &#123;    ArticleDO article = ArticleConverter.toArticleDo(req, author);    String content = imageService.mdImgReplace(req.getContent());    return transactionTemplate.execute(new TransactionCallback&lt;Long&gt;() &#123;        @Override        public Long doInTransaction(TransactionStatus status) &#123;            if (NumUtil.nullOrZero(req.getArticleId())) &#123;                return insertArticle(article, content, req.getTagIds());            &#125; else &#123;                return updateArticle(article, content, req.getTagIds());            &#125;        &#125;    &#125;);&#125;\n\n\nexecute() 方法接收一个 TransactionCallback 回调，回调中的 doInTransaction() 方法会在事务内执行\n\n如果 doInTransaction() 正常返回，Spring 会自动提交事务；如果抛出异常，会自动回滚事务\n\nTransactionStatus 对象可以用来手动控制事务（比如 status.setRollbackOnly() 强制回滚）\n\n\n📋 使用注意事项\n使用场景\n\n首先确定事务的使用场景，什么时候要用事务，不要瞎用，就比如非常简单的只读场景，那么什么场景需要用呢？\n\n当一个基础的业务单元 (如对外提供的 http 接口，service 方法)，存在 &gt;&#x3D;2 的数据变更时，就需要考虑，部分更新成功，部分更新失败是否会出现脏数据，是否会有影响。\n若是：则可以考虑引入事务\n若否：不建议加入事务\n\n\n只有一个数据变更，但是后续有强依赖这个数据的逻辑，也需要加入事务\n比如接到支付成功消息，我要做一个校对的后台任务\n我的业务逻辑是：先调用第三方校验是否属实，然后更新本地状态为成功，最后 MQ 方式通知订单状态变更\n此时我们需要将第二步数据变更与第三步消息通知放在事务中，只要通知失败，我们还是不更新本地状态，避免出现我们校验成功了，但是订单还是未支付\n\n\n\n\n使用建议\n\n\n避免大事务，只在需要的地方加事务\n注意分布式事务场景\n所有的操作，走索引，避免出现锁表\n减少范围、大批量的数据处理场景\n如果业务支撑，可以降低隔离级别，一是减少隔离级别带来的附加成本，二则是可以避免某些场景下的死锁\n\nhttps://github.com/liuyueyi/spring-boot-demo/tree/master/spring-boot/101-jdbctemplate-transaction\n","categories":["基础知识","开发"],"tags":["实例","事务"]}]